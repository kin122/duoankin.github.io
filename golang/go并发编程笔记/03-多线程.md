#### 线程
线程的概念：线程算是进程中的控制流。进程中必须会有主线程。进程系统调用pthread_create函数进行创建线程。线程不可能独立于进程存在，线程的生命周期不可能预约所属进程的生命周期。  
线程使用的特征：
* 所有的线程都有自己的线程栈，并以此存储自己的私有数据。这些线程的线程栈都包含在其所属进程的虚拟内存地址中。
* 同一个进程内的很多资源都可以被其所创建的线程共享，这些资源包括当前进程的虚拟内存地址中存储的代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符。
* 同一个进程中多个线程运行的一定是同一个程序，只是具体的控制流程和执行的函数可能会不同。
* 由于进程中所有的虚拟内存地址中存储的代码、数据和资源都不需要复制，创建线程相对简单很多。
##### 线程的标识
* 每个线程都有一个自己的线程ID（TID）
* 线程ID在系统范围内不唯一，在进程范围内唯一
* 线程ID由操作系统内核分配维护，进程一般只在调试阶段需要关注。
##### 线程的控制
线程之间的关系都是平等的，之间没有家族式的树状层级关系。  
具体的线程管理有以下四种：
1. 创建线程：start函数，通过调用系统调用pthread_create来创建新的线程，创建线程成功则得到新线程的ID。*主线程在其所属进程启动时创建，因此它的创建不在此论述范围之内。*
2. 终止线程：
    * 线程可以通过多种方式终止同一个进程中的其它线程，其中一种方式就是调用系统调用pthread_cancel方法，该函数的作用是取消掉给定线程ID代表的那个线程。
    * pthread_cancel会向目标线程发出请求，要求线程终止执行，但是该函数不等待目标线程对请求做出响应。
    * 默认情况下，目标线程总是会接收线程去校请求，不过会等到时机成熟的时候，才会去响应取消请求
3. 连接已终止的线程
    * 此操作由系统调用pthread_join执行，该函数会一直等待给定线程ID的线程终止，并把该线程执行的start函数的返回值告知调用线程。
    * 如果目标线程已经处于终止状态，则该函数立即返回。
    * 此操作就像把调用线程放置在目标线程后面，当目标线程把流程控制权交出是，调用线程会接过流程控制权并继续执行pthread_join函数调用之后的代码。这也就是称之为**连接**的缘由。
    * 异步线程没有层级关系，任务交出后不会等待结果，因此有了连接获取结果的收尾阶段。
    * 实际情况中，一个线程可以被连接，那么在终止之时就必须连接，否则就会变成僵尸进程。
4. 分离线程
    * 将一个线程分离意味着它不再是一个可以连接的线程。默认情况下，一个线程总可以被其他线程连接
    * 分离线程的目的是让操作系统内核在目标线程终止时自动进行清理和销毁工作
    * 分离操作不可逆， 无法使一个不可连接的线程变回可连接的状态
    * 对于一个已经分离的线程，执行终止操作仍然会起作用
    * 分离操作由系统调用pthread_detach执行，接受线程ID参数
 
线程自身也有两种控制：
1. 终止。
    * return语句：自身线程在strat函数中执行return，则线程随着start函数终止而终止；主线程执行return则当前进程所有线程都终止。
    * exit语句：进程内所有线程都终止
    * pthread_exit语句：这种方式，主线程调用后，只有主线程自己被终止，其它线程依旧照常运行
2. 分离。
    * 线程自身分离和分离其它线程的方式没有什么不同，都是调用pthread_detach函数。
##### 线程的状态
![linux线程状态转换](https://github.com/kin122/duoankin.github.io/blob/main/golang/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.xmind)  
在线程状态转换中有下列一些规则：
1. 正在运行的线程可能会有某些原因阻塞，进而转换为睡眠状态。此处的原因包括但不限于等待未完成的IO操作、等待还未接收到的信号、等待获得互斥量、等待某个条件变量。后两者都属于因同步而产生的线程阻塞
2. 阻塞线程等待的事件满足时，会从睡眠状态转出，但并不立即进入运行状态，而是就绪状态。
3. 线程进入就绪状态后，如果CPU处于空闲状态，那么立即运行
4. 在运行状态的的线程有时也会因CPU被其他线程抢占而失去运行时机，从而转回至就绪状态并等待。
5. 内核的调度器会按照一定的算法和策略使得线程在运行/就绪/睡眠三个状态转换。
6. 一般线程执行结束自己调用return/pthread_exit或者其它调用pthread_cancel后，如果线程没有分离过且没有其它线程与他连接，那么当前线程会进入僵尸状态而非终止状态。
7. 当且仅当有其他线程与之连接后（比如主线程来回收），当前线程才会从僵尸状态转换至终止状态。
8. 有两个操作可以使得当前线程进入终止状态，exit函数和主线程的return语句。
##### 线程的调度
##### 线程的实现模型
1. 用户级线程模型
2. 内核级线程模型
3. 两级线程模型

#### 线程同步

##### 共享数据的一致性

##### 互斥量

##### 条件变量

##### 线程安全性
