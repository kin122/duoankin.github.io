#### 线程
线程的概念：线程算是进程中的控制流。进程中必须会有主线程。进程系统调用pthread_create函数进行创建线程。线程不可能独立于进程存在，线程的生命周期不可能预约所属进程的生命周期。  
线程使用的特征：
* 所有的线程都有自己的线程栈，并以此存储自己的私有数据。这些线程的线程栈都包含在其所属进程的虚拟内存地址中。
* 同一个进程内的很多资源都可以被其所创建的线程共享，这些资源包括当前进程的虚拟内存地址中存储的代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符。
* 同一个进程中多个线程运行的一定是同一个程序，只是具体的控制流程和执行的函数可能会不同。
* 由于进程中所有的虚拟内存地址中存储的代码、数据和资源都不需要复制，创建线程相对简单很多。
##### 线程的标识
* 每个线程都有一个自己的线程ID（TID）
* 线程ID在系统范围内不唯一，在进程范围内唯一
* 线程ID由操作系统内核分配维护，进程一般只在调试阶段需要关注。
##### 线程的控制
线程之间的关系都是平等的，之间没有家族式的树状层级关系。  
具体的线程管理有以下四种：
1. 创建线程：start函数，通过调用系统调用pthread_create来创建新的线程，创建线程成功则得到新线程的ID。*主线程在其所属进程启动时创建，因此它的创建不在此论述范围之内。*
2. 终止线程：
    * 线程可以通过多种方式终止同一个进程中的其它线程，其中一种方式就是调用系统调用pthread_cancel方法，该函数的作用是取消掉给定线程ID代表的那个线程。
    * pthread_cancel会向目标线程发出请求，要求线程终止执行，但是该函数不等待目标线程对请求做出响应。
    * 默认情况下，目标线程总是会接收线程去校请求，不过会等到时机成熟的时候，才会去响应取消请求
3. 连接已终止的线程
    * 此操作由系统调用pthread_join执行，该函数会一直等待给定线程ID的线程终止，并把该线程执行的start函数的返回值告知调用线程。
    * 如果目标线程已经处于终止状态，则该函数立即返回。
    * 此操作就像把调用线程放置在目标线程后面，当目标线程把流程控制权交出是，调用线程会接过流程控制权并继续执行pthread_join函数调用之后的代码。这也就是称之为**连接**的缘由。
    * 异步线程没有层级关系，任务交出后不会等待结果，因此有了连接获取结果的收尾阶段。
    * 实际情况中，一个线程可以被连接，那么在终止之时就必须连接，否则就会变成僵尸进程。
4. 分离线程
    * 将一个线程分离意味着它不再是一个可以连接的线程。默认情况下，一个线程总可以被其他线程连接
    * 分离线程的目的是让操作系统内核在目标线程终止时自动进行清理和销毁工作
    * 分离操作不可逆， 无法使一个不可连接的线程变回可连接的状态
    * 对于一个已经分离的线程，执行终止操作仍然会起作用
    * 分离操作由系统调用pthread_detach执行，接受线程ID参数
 
线程自身也有两种控制：
1. 终止。
    * return语句：自身线程在strat函数中执行return，则线程随着start函数终止而终止；主线程执行return则当前进程所有线程都终止。
    * exit语句：进程内所有线程都终止
    * pthread_exit语句：这种方式，主线程调用后，只有主线程自己被终止，其它线程依旧照常运行
2. 分离。
    * 线程自身分离和分离其它线程的方式没有什么不同，都是调用pthread_detach函数。
##### 线程的状态
##### 线程的调度
##### 线程的实现模型
1. 用户级线程模型
2. 内核级线程模型
3. 两级线程模型

#### 线程同步

##### 共享数据的一致性

##### 互斥量

##### 条件变量

##### 线程安全性
