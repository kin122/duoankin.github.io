#### 线程
线程的概念：线程算是进程中的控制流。进程中必须会有主线程。进程系统调用pthread_create函数进行创建线程。线程不可能独立于进程存在，线程的生命周期不可能预约所属进程的生命周期。  
线程使用的特征：
* 所有的线程都有自己的线程栈，并以此存储自己的私有数据。这些线程的线程栈都包含在其所属进程的虚拟内存地址中。
* 同一个进程内的很多资源都可以被其所创建的线程共享，这些资源包括当前进程的虚拟内存地址中存储的代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符。
* 同一个进程中多个线程运行的一定是同一个程序，只是具体的控制流程和执行的函数可能会不同。
* 由于进程中所有的虚拟内存地址中存储的代码、数据和资源都不需要复制，创建线程相对简单很多。
##### 线程的标识
* 每个线程都有一个自己的线程ID（TID）
* 线程ID在系统范围内不唯一，在进程范围内唯一
* 线程ID由操作系统内核分配维护，进程一般只在调试阶段需要关注。
##### 线程的控制
线程之间的关系都是平等的，之间没有家族式的树状层级关系。  
具体的线程管理有以下四种：
1. 创建线程：start函数，通过调用系统调用pthread_create来创建新的线程，创建线程成功则得到新线程的ID。*主线程在其所属进程启动时创建，因此它的创建不在此论述范围之内。*
2. 终止线程：
    * 线程可以通过多种方式终止同一个进程中的其它线程，其中一种方式就是调用系统调用pthread_cancel方法，该函数的作用是取消掉给定线程ID代表的那个线程。
    * pthread_cancel会向目标线程发出请求，要求线程终止执行，但是该函数不等待目标线程对请求做出响应。
    * 默认情况下，目标线程总是会接收线程去校请求，不过会等到时机成熟的时候，才会去响应取消请求
3. 连接已终止的线程
    * 此操作由系统调用pthread_join执行，该函数会一直等待给定线程ID的线程终止，并把该线程执行的start函数的返回值告知调用线程。
    * 如果目标线程已经处于终止状态，则该函数立即返回。
    * 此操作就像把调用线程放置在目标线程后面，当目标线程把流程控制权交出是，调用线程会接过流程控制权并继续执行pthread_join函数调用之后的代码。这也就是称之为**连接**的缘由。
    * 异步线程没有层级关系，任务交出后不会等待结果，因此有了连接获取结果的收尾阶段。
    * 实际情况中，一个线程可以被连接，那么在终止之时就必须连接，否则就会变成僵尸进程。
4. 分离线程
    * 将一个线程分离意味着它不再是一个可以连接的线程。默认情况下，一个线程总可以被其他线程连接
    * 分离线程的目的是让操作系统内核在目标线程终止时自动进行清理和销毁工作
    * 分离操作不可逆， 无法使一个不可连接的线程变回可连接的状态
    * 对于一个已经分离的线程，执行终止操作仍然会起作用
    * 分离操作由系统调用pthread_detach执行，接受线程ID参数
 
线程自身也有两种控制：
1. 终止。
    * return语句：自身线程在strat函数中执行return，则线程随着start函数终止而终止；主线程执行return则当前进程所有线程都终止。
    * exit语句：进程内所有线程都终止
    * pthread_exit语句：这种方式，主线程调用后，只有主线程自己被终止，其它线程依旧照常运行
2. 分离。
    * 线程自身分离和分离其它线程的方式没有什么不同，都是调用pthread_detach函数。
##### 线程的状态
![linux线程状态转换](https://github.com/kin122/duoankin.github.io/blob/main/golang/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.xmind)  
在线程状态转换中有下列一些规则：
1. 正在运行的线程可能会有某些原因阻塞，进而转换为睡眠状态。此处的原因包括但不限于等待未完成的IO操作、等待还未接收到的信号、等待获得互斥量、等待某个条件变量。后两者都属于因同步而产生的线程阻塞
2. 阻塞线程等待的事件满足时，会从睡眠状态转出，但并不立即进入运行状态，而是就绪状态。
3. 线程进入就绪状态后，如果CPU处于空闲状态，那么立即运行
4. 在运行状态的的线程有时也会因CPU被其他线程抢占而失去运行时机，从而转回至就绪状态并等待。
5. 内核的调度器会按照一定的算法和策略使得线程在运行/就绪/睡眠三个状态转换。
6. 一般线程执行结束自己调用return/pthread_exit或者其它调用pthread_cancel后，如果线程没有分离过且没有其它线程与他连接，那么当前线程会进入僵尸状态而非终止状态。
7. 当且仅当有其他线程与之连接后（比如主线程来回收），当前线程才会从僵尸状态转换至终止状态。
8. 有两个操作可以使得当前线程进入终止状态，exit函数和主线程的return语句。
##### 线程的调度
调度器会把时间划分为极小的时间片并把这些时间分配给不同的线程，以使众多的线程都有机会在CPU上运行。  
一个线程什么时候能够获得CPU时间，以及它能够在CPU上运行多久，都属于调度器的工作范畴。线程调度也成为线程间的上下文切换。  
线程的执行主要分为CPU计算和IO等待。线程的动态优先级（调度器计算趋向所得）是CPU计算低于IO等待。静态优先级是调度器所需要执行的CPU时间分配优先级，高于动态优先级。  
调度队列规则：
1. 所有等待使用cpu的线程会按照动态优先级从高到低的顺序排列，并依序放到该CPU对应的运行队列中
2. 每个CPU都有两个优先级阵列：一个用于存放正在等待运行的线程，称为激活的优先级阵列；另一个用于存放已经运行过但还未完成的线程，称为过期的优先级阵列
3. 优先级阵列式一个有若干个链表组成的数组，一个链表只会包含具有相同优先级的线程，当一个线程放入某个优先级阵列式，只会放在与其优先级对应的那个链表末尾。
4. 下一个运行的线程总是会从激活的优先级阵列中选出。如果调度器发现某个线程已经占用CPU很长时间（该时间只会小于或等于给于该线程的时间片），并且激活的优先级阵列中还有优先级与它相同的线程在等待运行，那么调度器就会让那个等待的线程在CPU上运行，而被换下的线程会排入过期的优先级阵列。
5. 当激活的优先级阵列中没有等待运行的线程时，调度器会把这两个优先级阵列的身份互换。
6. 线程也会根据条件被阻塞进入睡眠状态，线程的睡眠状态也分为可中断和不可中断两种。
7. 线程会因为等待某个事件或者条件的发生而加入到对应的等待队列，随即进入等待状态。当事件发生或者条件满足时，内核会通知对应的等待队列中的所有线程，这些线程因此被唤醒进入适当的运行队列。调度器往往会微微调高被唤醒的线程动态优先级。

计算机在多个CPU的情况下，会根据每个CPU的负载系数（load的数据？）进行调整，平衡负载。

##### 线程的实现模型
线程的三个实现模型的最大区别在于线程与内核调度实体（Kernel Scheduling Entity 又称KSE）之间的对应关系
1. 用户级线程模型
    * 线程由用户级别的线程库全权管理，与内核调度器无关。
    * 线程调度并不能真正并发；进程中的多个线程也无法被分配给不同的CPU；线程库内的线程优先级与内核设定的规则无关。
    * 程序的移植性更强
    * 多个用户级线程的进程与一个KSE对应，即M:1
2. 内核级线程模型
    * 线程由内核管理，一切应用线程的操作由内核提供的系统调度完成。
    * 每个线程都与一个KSE对应，即1：1。
    * 在同步条件下，线程的使用可能会有影响。
    * 内核线程的管理成本会高很多，会给调度器造成较大的负担，且甚至会影响操作系统的性能。
    * 操作系统最新线程库的实现(NPTL)
3. 两级线程模型
    * 结合之前两个的优势而来，多对多的线程实现，M:N
    * 一个进程与多个KSE关联
    * 进程中的线程并不与KSE绑定关系，可以根据情况映射到一个KSE，也可以多个。
    * 目的时为了减少内核资源的消耗，提高使用效率
    * goroutine（GO例程）采用了类似的两级线程模型

#### 线程同步
线程同步是为了线程之间更好的协同工作或者维持共享数据的一致性。

##### 共享数据的一致性
一个进程中所拥有的相当一部分虚拟内存的地址都可以被该进程中所有线程共享，所以共享数据大多以内存空间作为载体。  
支持共享数据一致性的逻辑设定，主要以多线程程序的设计方案有关。  
**临界区**是只能被串行化访问或者执行的某个资源或者某个代码，因此也被称为串行区域。  
保证临界区的方法主要有：原子操作/互斥量/条件变量（*此处主要涉及并发程序的设计*）

##### 互斥量
互斥量的概念：在同一时刻，只允许一个线程处于临界区之内的约束成为互斥（mutex）。每个线程在进入临界区之前，都必须先锁定某个对象，只有成功锁定对象的线程才允许进入临界区，否则就会阻塞。这个对象称为互斥对象或者互斥量。  
  
互斥量的状态：
* 互斥量只有两种可能状态，已锁定状态和未锁定状态。
* 互斥量每次只能锁定一次，不能二次**锁定**。
* 成功锁定互斥量的线程就是该互斥量的所有者。只有互斥量的所有者才能**解锁**。

互斥量的使用规则  
* 互斥量**也属于共享资源**，必须能够被所有相关线程访问到。因此互斥量的的变量或者常量一般不是局部的。但在满足之前条件下互斥量的访问权限也许最小化。
* 互斥量的初始化操作总是在任何线程真正使用它之前进行。经过初始化的互斥量会处于未锁定状态。如果多个现场的代码中都包含了对同一个互斥量的初始化操作，那么必须保证该互斥量只会被初始化一次。
* 线程在离开临界区时候必须要及时解锁互斥量，不然会造成不必要的性能损耗甚至死锁。
* 一般情况下，应该尽量减少适用互斥量。每个互斥量保护的临界区应该在合理的范围内且尽量大。
* 如果发现多个线程会频繁出入某个较大的临界区，且之间的访问存在冲突（互斥量管理的功能太多），就应该吧这个较大的临界区切分成若干较小的临界区，并使用不同的互斥量保护。
* 切分后由不同的互斥量保护的临界区包含了对同一个共享资源的同一种操作，那么此临界区的切分就是不成功的。

临界区重叠造成死锁的解决办法：试锁定-回退；固定顺序锁定  
1. **试锁定-回退**
    * 在执行一个代码块的时候，需要先后（顺序不定）锁定两个互斥量，那么在成功锁定其中一个互斥量之后应该使用试锁定来锁定另一个互斥量。如果试锁定第二个互斥量失败，就把已锁定的第一个互斥量解锁，并重新对这两个互斥量进行锁定和试锁定。
    * 如果需要锁定的互斥量多余两个，那么总是先锁定其中一个，然后再按照上面的方法试锁定其他互斥量并在必要时进行回退。
    * 这里的试锁定代表的是操作系统的线程库提供的一个函数，它会尝试对一个互斥量进行锁定。若锁定失败，则该函数会直接返回一个错误码，而不是被阻塞在那，这样就避免了死锁。
    * 回退环节则是及时解锁避免资源浪费。
    * 这个方法的复杂性相对打了很多，尤其是再分别对多个互斥量的锁定操作之间夹杂着其他操作时。
    * 在使用试锁定和回退时，对多个互斥量解锁的顺序也需要与锁定他们的顺序完全相反。特别是**一定要最后解锁那个第一个锁定的互斥量**，这样可以很大程度减少回退的次数。
2. **固定顺序锁定**
    * 解锁操作得顺序与其锁定操作的顺序相反。
    * 保证一个线程完全离开这些重叠的临界区之前，不会有其它相同需要锁定那些互斥量的线程进入。
    * 这样简单但是也相对降低了程序的灵活性，且有场景限制（*不能确定线程对多个临界区访问顺序的情况下，就不可使用*）

**死锁是使用互斥量时需要特别注意的唯一问题**
##### 条件变量
条件变量的概念：  
原因：临界区并不能保证所有情况的发生，互斥量可能由于第三方原因死锁失效。  
等待通知：  
单发通知：  
广播通知：  

##### 线程安全性
可重入（reentrant）的概念

#### 多进程与多线程
多进程与多线程之间的关系与取舍  

并发与并行  
协程与多线程（多线程模型的区别）  

主要指标：
* 响应时间
* 吞吐量
* 程序正确性
* 程序可伸缩性，强调可伸缩性的因素

正确性与可伸缩性的互相矛盾  

提高并发程序设计质量的建议：即不失去程序正确性的前提下最大限度提高程序的可伸缩性。
* 控制临界区的纯度
* 控制临界区的粒度
* 减少临界区中代码的执行耗时
* 避免长时间持有互斥量
* 优先使用原子操作而不是互斥量
