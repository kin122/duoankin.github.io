#### 线程
线程的概念：线程算是进程中的控制流。进程中必须会有主线程。进程系统调用pthread_create函数进行创建线程。线程不可能独立于进程存在，线程的生命周期不可能预约所属进程的生命周期。  
线程使用的特征：
* 所有的线程都有自己的线程栈，并以此存储自己的私有数据。这些线程的线程栈都包含在其所属进程的虚拟内存地址中。
* 同一个进程内的很多资源都可以被其所创建的线程共享，这些资源包括当前进程的虚拟内存地址中存储的代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符。
* 同一个进程中多个线程运行的一定是同一个程序，只是具体的控制流程和执行的函数可能会不同。
* 由于进程中所有的虚拟内存地址中存储的代码、数据和资源都不需要复制，创建线程相对简单很多。
##### 线程的标识
* 每个线程都有一个自己的线程ID（TID）
* 线程ID在系统范围内不唯一，在进程范围内唯一
* 线程ID由操作系统内核分配维护，进程一般只在调试阶段需要关注。
##### 线程的控制
线程之间的关系都是平等的，之间没有家族式的树状层级关系。  
具体的线程管理有以下四种：
1. 创建线程：start函数，通过调用系统调用pthread_create来创建新的线程，创建线程成功则得到新线程的ID。*主线程在其所属进程启动时创建，因此它的创建不在此论述范围之内。*
2. 终止线程：
    * 线程可以通过多种方式终止同一个进程中的其它线程，其中一种方式就是调用系统调用pthread_cancel方法，该函数的作用是取消掉给定线程ID代表的那个线程。
    * pthread_cancel会向目标线程发出请求，要求线程终止执行，但是该函数不等待目标线程对请求做出响应。
    * 默认情况下，目标线程总是会接收线程去校请求，不过会等到时机成熟的时候，才会去响应取消请求
3. 连接已终止的线程
    * 此操作由系统调用pthread_join执行，该函数会一直等待给定线程ID的线程终止，并把该线程执行的start函数的返回值告知调用线程。
    * 如果目标线程已经处于终止状态，则该函数立即返回。
    * 此操作就像把调用线程放置在目标线程后面，当目标线程把流程控制权交出是，调用线程会接过流程控制权并继续执行pthread_join函数调用之后的代码。这也就是称之为**连接**的缘由。
    * 异步线程没有层级关系，任务交出后不会等待结果，因此有了连接获取结果的收尾阶段。
    * 实际情况中，一个线程可以被连接，那么在终止之时就必须连接，否则就会变成僵尸进程。
4. 分离线程
    * 将一个线程分离意味着它不再是一个可以连接的线程。默认情况下，一个线程总可以被其他线程连接
    * 分离线程的目的是让操作系统内核在目标线程终止时自动进行清理和销毁工作
    * 分离操作不可逆， 无法使一个不可连接的线程变回可连接的状态
    * 对于一个已经分离的线程，执行终止操作仍然会起作用
    * 分离操作由系统调用pthread_detach执行，接受线程ID参数
 
线程自身也有两种控制：
1. 终止。
    * return语句：自身线程在strat函数中执行return，则线程随着start函数终止而终止；主线程执行return则当前进程所有线程都终止。
    * exit语句：进程内所有线程都终止
    * pthread_exit语句：这种方式，主线程调用后，只有主线程自己被终止，其它线程依旧照常运行
2. 分离。
    * 线程自身分离和分离其它线程的方式没有什么不同，都是调用pthread_detach函数。
##### 线程的状态
![linux线程状态转换](https://github.com/kin122/duoankin.github.io/blob/main/golang/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.xmind)  
在线程状态转换中有下列一些规则：
1. 正在运行的线程可能会有某些原因阻塞，进而转换为睡眠状态。此处的原因包括但不限于等待未完成的IO操作、等待还未接收到的信号、等待获得互斥量、等待某个条件变量。后两者都属于因同步而产生的线程阻塞
2. 阻塞线程等待的事件满足时，会从睡眠状态转出，但并不立即进入运行状态，而是就绪状态。
3. 线程进入就绪状态后，如果CPU处于空闲状态，那么立即运行
4. 在运行状态的的线程有时也会因CPU被其他线程抢占而失去运行时机，从而转回至就绪状态并等待。
5. 内核的调度器会按照一定的算法和策略使得线程在运行/就绪/睡眠三个状态转换。
6. 一般线程执行结束自己调用return/pthread_exit或者其它调用pthread_cancel后，如果线程没有分离过且没有其它线程与他连接，那么当前线程会进入僵尸状态而非终止状态。
7. 当且仅当有其他线程与之连接后（比如主线程来回收），当前线程才会从僵尸状态转换至终止状态。
8. 有两个操作可以使得当前线程进入终止状态，exit函数和主线程的return语句。
##### 线程的调度
调度器会把时间划分为极小的时间片并把这些时间分配给不同的线程，以使众多的线程都有机会在CPU上运行。  
一个线程什么时候能够获得CPU时间，以及它能够在CPU上运行多久，都属于调度器的工作范畴。线程调度也成为线程间的上下文切换。  
线程的执行主要分为CPU计算和IO等待。线程的动态优先级（调度器计算趋向所得）是CPU计算低于IO等待。静态优先级是调度器所需要执行的CPU时间分配优先级，高于动态优先级。  
调度队列规则：
1. 所有等待使用cpu的线程会按照动态优先级从高到低的顺序排列，并依序放到该CPU对应的运行队列中
2. 每个CPU都有两个优先级阵列：一个用于存放正在等待运行的线程，称为激活的优先级阵列；另一个用于存放已经运行过但还未完成的线程，称为过期的优先级阵列
3. 优先级阵列式一个有若干个链表组成的数组，一个链表只会包含具有相同优先级的线程，当一个线程放入某个优先级阵列式，只会放在与其优先级对应的那个链表末尾。
4. 下一个运行的线程总是会从激活的优先级阵列中选出。如果调度器发现某个线程已经占用CPU很长时间（该时间只会小于或等于给于该线程的时间片），并且激活的优先级阵列中还有优先级与它相同的线程在等待运行，那么调度器就会让那个等待的线程在CPU上运行，而被换下的线程会排入过期的优先级阵列。
5. 当激活的优先级阵列中没有等待运行的线程时，调度器会把这两个优先级阵列的身份互换。
6. 线程也会根据条件被阻塞进入睡眠状态，线程的睡眠状态也分为可中断和不可中断两种。
7. 线程会因为等待某个事件或者条件的发生而加入到对应的等待队列，随即进入等待状态。当事件发生或者条件满足时，内核会通知对应的等待队列中的所有线程，这些线程因此被唤醒进入适当的运行队列。调度器往往会微微调高被唤醒的线程动态优先级。

计算机在多个CPU的情况下，会根据每个CPU的负载系数（load的数据？）进行调整，平衡负载。

##### 线程的实现模型
线程的三个实现模型的最大区别在于线程与内核调度实体（Kernel Scheduling Entity 又称KSE）之间的对应关系
1. 用户级线程模型
    * 线程由用户级别的线程库全权管理，与内核调度器无关。
    * 线程调度并不能真正并发；进程中的多个线程也无法被分配给不同的CPU；线程库内的线程优先级与内核设定的规则无关。
    * 程序的移植性更强
    * 多个用户级线程的进程与一个KSE对应，即M:1
2. 内核级线程模型
    * 线程由内核管理，一切应用线程的操作由内核提供的系统调度完成。
    * 每个线程都与一个KSE对应，即1：1。
    * 在同步条件下，线程的使用可能会有影响。
    * 内核线程的管理成本会高很多，会给调度器造成较大的负担，且甚至会影响操作系统的性能。
    * 操作系统最新线程库的实现(NPTL)
3. 两级线程模型
    * 结合之前两个的优势而来，多对多的线程实现，M:N
    * 一个进程与多个KSE关联
    * 进程中的线程并不与KSE绑定关系，可以根据情况映射到一个KSE，也可以多个。
    * 目的时为了减少内核资源的消耗，提高使用效率
    * goroutine（GO例程）采用了类似的两级线程模型

#### 线程同步
线程同步是为了线程之间更好的协同工作或者维持共享数据的一致性。

##### 共享数据的一致性
一个进程中所拥有的相当一部分虚拟内存的地址都可以被该进程中所有线程共享，所以共享数据大多以内存空间作为载体。  
支持共享数据一致性的逻辑设定，主要以多线程程序的设计方案有关。  
**临界区**是只能被串行化访问或者执行的某个资源或者某个代码，因此也被称为串行区域。  
保证临界区的邮箱发发主要有：原子操作/互斥量/条件变量

##### 互斥量

##### 条件变量

##### 线程安全性
