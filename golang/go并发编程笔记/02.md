## 语法概览
### 1. 基本要素
词法元素：标识符（identifier）/关键词（keyword）/字面量（literal）/分隔符（delimiter）/操作符（operator）
#### 1.1 标识符
标识符表示程序实体，同一代码块中不允许出现同名的程序实体，*因此出现了import的规则*  
预定义标识符：  
* 所有基本数据类型的名称
* 接口类型的error
* 常量true false iota
* 所有内建函数的名称：append/cap/close/complex/copy/delete/imag/len/make/new/panic/print/println/real/recover

空标识符：由一个下划线_表示，绕过编译器检查，仿佛代码中的垃圾桶，对无用的返回对象抛弃。
#### 1.2 关键字
关键字指被编程语言保留的字符序列，不能用作标识符。*注意与预定义标识符的区别*  
关键字类型：
1. 程序声明：import/package
2. 程序实体声明和定义： chan/const/func/interface/map/struct/type/var
3. 程序流程控制：go/select/break/case/continue/default/defer/else/fallthrough/for/goto/if *并发编程相关：go/chan/select*

空接口：interface{}。go语言中任何类型都是空接口类型的实现类型。  
type与类型/潜在类型互转的关系。
#### 1.3 字面量
值的标记，golang中字面量适用范围更广泛。*标记变量/构建变量结构/复合变量实体*  
1. 基础数据类型的字面量：比如表示浮点数类型的12E-3
2. 类型字面量：用于构造各种自定义的复合数据类型的类型字面量。  
```
type Name struct {
    Forename string
    Surname string
}
```
3. 复合字面量:用于表示复合数据类型的值的复合字面量。可以用来构造struct/array/slice/map类型的值。由字面类型以及被花括号包裹的复合元素的列表组成。  
```
Name{Forename:"Robert",Surname:"Hao"}
```
#### 1.4 操作符
即运算符。21个运算符分：算术/比较/逻辑/地址/接收 5类。  
一元运算符最高优先级，二元运算符优先级值越大越高。  
++与--是语句不是表达式，不存在操作符顺序。
#### 1.5 表达式
表达式是把操作符和函数作用于操作数的计算方法。表达式是构成具有词法意义的代码的最基本元素。
1. 选择表达式：选择一个值中的字段或者方法。context.Speaker
2. 索引表达式：选取数组、切片、字符串或者字典值中的某个元素。array[1]
3. 切片表达式：选取数组、数组指针、切片或字符串值中的某个范围的元素。slice1[1:3]
4. 类型断言：判断一个接口值的实际类型是否为某个类型，或一个非接口值的类型是否实现了某个接口类型。v1.(l1)
5. 调用表达式：调用一个函数或者一个值的方法。v1.M1()

关于类型断言：
1. 如果v1是一个非接口值，那么必须在做类型断言之前把它转换成接口值。使用空接口实现，interface{}(v1).(l1)
2. 如果类型断言结果为否，意味着该类型断言失败，失败则panic。解决方法`i1,ok := interface{}(v1).(l1)`。如果成功i1就会是经过类型转换后的I1类型的值，否则使用l1类型的默认值。这样可以避免panic。  
*完整表达式如下*
```
var i1 l1
var ok bool
i1,ok = interface{}(v1).(l1)
```


### 2. 基本类型
基本类型用于常量的声明。  
rune为golang特有的数据类型，专用于存储unicode字符。  
字符串字面量有两种表达形式：原生字符串字面量（由反引号包裹）；解释性字符串字面量（由双引号包裹）。前者所见即所得，后者可以解析转义字符。  
在官方的命名规范中，常量也是驼峰法。但实际常量可以大小一致来保证其可辨性。  
### 3. 高级类型
#### 3.1 数组
基础的高级类型。长度一旦声明不可变。  
#### 3.2 切片
一种对数组的包装形式。  
1. 不携带长度信息，长度可变。
2. 元素类型相同，则切片类型相同。
3. 切片的零值为nil，零值长度和容量都是0。

切片值相当于对某个底层数组的引用。内部结构包含3个元素：指向底层数组中某个元素的指针、切片的长度以及切片的容量。  
*注意新旧切片之可能指向不同的底层数组，若新切片之的底层数组的长度不足以完成元素的追加操作，它将会被更长的底层数组替换*
#### 3.3 字典
字典类型是散列表（hash table）的一个实现。散列表是为了实现关联数组。关联数组则是用于表示键值对的无序集合的一种抽象数据类型。  
*字典在golang和python中特点相似*
#### 3.4 函数和方法
函数类型为一等类型。函数可以是被传递使用的值，也可以是参数，也可以闭包。*函数的用法是相对活跃的*  
```
func divide(dividend int, divisor int)(result int ,err error){
    if divisor == 0 {
        err = error.New("xxxx")
        return
    }
    result = dividend/divisor
    return
}
```
*return后不返回变量是因为在func声明的时候定义了result*  
go有个惯用的用法，error类型的结果作为函数结果列表的最后一员。  
必包的使用：  
```
type binop func(operate1 int ,operate2 int)(result int,err error)
func operate(op1 int,op2 int,bop binop)(result int,err error){
    if bop == nil {
        err = error.New("XXXXXX")
        return
    }
    return bop(op1,op2)
}
```
值方法与指针方法遵循下列规则：
* 接收者变量代表的值实际上是源值得一个复制品。如果这个值不是指针类型，那么在值方法中自然就没有途径改变源值。而指针值与其复制品指向的肯定是同一个值，所以在指针方法中就存在改变源值得途径。这里有个例外，那就是如果接收者类型是某个引用类型或者他的别名类型，那么即使是值方法，也可以改变源值。
* 对于某个非指针得数据类型，与它关联的方法的集和中只包含他的值方法。而对于它的指针类型，其方法集合中既包含值方法也包含指针方法。不过，在非指针数据类型的值上，也是能够调用其指针方法的。*此特性对编写接口类型的实现类型很有用*
#### 3.5 接口
接口类型用于定义一组行为，每个行为都由一个方法声明表示。*值方法与指针方法使用的意义？*  
go的数据类型之间并不存在继承关系，接口类型之间也是如此。不过接口类型的声明中可以嵌入任意其它接口类型。  
#### 3.6 结构体
结构体类型不仅可以关联方法，而且可以由内置元素。  
在使用结构体字面量是可以忽略字段名称：
* 要么忽略掉所有字段的名称，要么都不忽略
* 字段值的顺序要与声明顺序一致，且不能够省略。
* 在不忽略字段名称的写法中，未被明确赋值的字段会自动被其类型的零值填充。  

**结构体类型属于值类型，数组类型也是**

### 4 流程控制
go 流程控制的特点：
* 没有do和while循环，只有一个更广义的for语句
* switch语句灵活多变，还可以用于类型判断
* if语句和switch语句都可以包含一条初始化子语句
* break语句和continue语句可以后跟一条标签（label）语句，以标识需要中止或者继续的代码块
* defer语句可以使我们更加方便地执行异常捕获和资源回收任务
* select语句也可以用于多分支选择，但至于通道配合使用
* go语句用于异步启用goroutine并执行指定函数

显式代码块：一个由花括号包裹的表达式和语句的序列。代码块中也可以不包含任何内容，即空代码块  
隐式代码块：
* 所有go代码形成了一个最大的代码块，即 全域代码块
* 每一个代码包中的代码共同组成了一个代码块，即 代码包代码块
* 每一个源码文件都是一个代码块，即 源码文件代码块
* 每一个if/for/switch/select语句都是一个代码块
* 每一个在switch或select语句中的case分支都是一个代码块

代码块的作用域范围规则:
* 一个预定义标识符的作用域式全域代码块
* 表示一个常量、变量、类型或函数（不包括方法），且声明在函数之外的标识符的作用域是当前的代码包代码块
* 被导入的代码包的名称的作用域是当前的源码文件代码块
* 表示方法接收者、方法参数或方法结果的标识符的作用域是当前的方法代码块
* 对于表示常量、变量、类型或者函数的标识符，如果被声明在函数内部，那么作用域就是包含其声明的那个最内层的代码块。

#### 4.1 if语句
#### 4.2 switch语句
* 可以在switch中使用fallthrough来向下一个case语句转移流程控制权。（*具体fallthrough待补全，注意与continue的区别*）。fallthrough不能用在switch的最后一个分支。
* switch语句可以进行类型判定，而不是值

#### 4.3 for语句
for与range表达式一起配对使用。其注意点：
* 若对数组、切片或者字符串进行迭代，且：=左边只有一个迭代变量时，一定要小心，这时只会得到其中元素的索引，而不是元素本身
* 迭代没有任何元素的数组值、为nil的切片值、为nil的字典值或为""的字符串值，并不会执行for语句中的代码。for语句在一开始就会直接结束执行。因为这些值得长度都为0
* 迭代为nil得通道值会让当前流程永远阻塞在for语句上

#### 4.4 defer语句
用于延迟调用指定得函数，只能出现在函数得内部，由defer关键字以及针对某个函数得调用表达式组成。被称为延迟函数。
```
func outerFunc(){
    defer fmt.Println("函数执行结束前一刻打印")
    fmt.Println("第一个被打印")
}
```
这里得outerFunc称为外围函数，调用outerFunc的那个函数称为调用函数。  
* 当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正结束执行。
* 当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。
* 当外围函数中的代码引发运行时的恐慌是，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩散至调用函数
* 在延迟函数中使用外部变量，应该通过参数传入，且这些参数的值会在当前defer语句执行时求出
* 同一个外围函数内多个延迟函数调用的执行顺序，会与其所所属的defer语句的执行顺序完全相反。

#### 4.5 panic和recover
recover与panic在多级方法调用时阻止恐慌
