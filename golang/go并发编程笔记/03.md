### 1. 理论基础
并发程序：允许串行程序运行在一个或多个可共享的CPU之上，同时也允许每个串行程序都运行在专门为它服务的CPU上。  
* 并发程序是指可以被同时发起执行的程序
* 并行程序则被设计成在并行的硬件上执行的并发程序
* 并发程序代表了所有可以实现并发行为的程序，包含了并行程序

并发程序的不确定性：即并发编程的混乱性  

并发程序内部的交互：同步与异步  

同步的作用是避免在并发**访问共享资源**时可能发生的冲突，以及确保有条不紊地传递数据  
同步的原则：
* 程序如果想使用一个共享资源，就必须先请求该资源并获取到对它的访问权。
* 程序不再需要某个资源的时候，它应该放弃对该资源的访问权
* 一个程序对资源的请求不应该导致其它正在访问的该资源的程序中断，而应该等到那个程序释放该资源之后再进行请求.*同一时刻，某个资源应该被一个程序占用，原子性？*

并发程序内部异步通讯：
* 异步这种方式使得数据可以不加延迟地发送给接收方。即使数据接收方还没有为接收数据做好准备，也不会造成数据发送方的等待。
* 数据会被临时存放在一个称为**通讯缓存的数据结构**中。通讯缓存时一种特殊的共享资源，它可以同时被多个程序使用。
* 数据接收方可以在准备就绪之后按照数据存入通讯缓存的顺序接收它们

### 2. 多进程编程
进程间通讯：inter-process communication  IPC  
IPC根据处理机制区分：
1. 基于通信
    * 以数据传送为手段：传送字节流的管道（pipe）和传送结构化对象的消息队列（message queue）
    * 以共享内存为手段：shared memory
2. 基于信号：操作系统的信号机制，signal，唯一异步IPC方法
3. 基于同步：信号量，semaphore

golang支持的IPC方法是管道、信号和socket  

进程的概念  
父进程和子进程，父进程使用fork来创建若干个子进程：
1. 每个子进程都是源自于它父进程的一个副本，它会获得父进程的数据段、堆和栈的副本，并与父进程共享代码段。
2. 子进程的内容是相互独立的，对副本的修改对其父进程和兄弟进程都是不可见的。*在副本创建方面，linux内核并不全盘复制父进程的数据，内核使用的是写时复制（copy on write COW）来提高进程创建的效率*
3. 刚创建的子进程也可以通过系统调用exec把一个新的程序加载到自己的内存中，原先在其内存中的数据段、堆、栈以及代码段就会欸替换掉。这样子进程执行的就是新程序

**关于linux内核处理父子进程**  
linux操作系统中的每一个进程都有父进程。所有的进程共同组成一个树状的结构。内核启动进程作为进程树的根，负责系统的初始化操作，它是所有进程的祖先，它的父进程就是自己。如果某一个进程先于它的子进程结束，那么这些子进程将会被内核启动进程收养，成为它的直接子进程。  

进程标识：
1. 进程的相关信息都会被记录在进程描述符中
2. 进程描述符不是一个简单的符号，而是一个复杂的数据结构
3. 进程ID是进程在操作系统中的唯一标识。1是内核启动进程
4. 进程id是一个非负整数且总是顺序的编号，进程id可以被重复使用。
5. 进程描述符还会包含当前进程的父进程ID，即PPID

golang可以用os代码表查看当前进程的PID和PPID
```
pid := os.Getpid()
ppid := os.Getppid()
```

**进程的状态**
1. 可运行状态：TASK_RUNNING 简称为R。程序立刻要或者正在CPU上运行。
2. 可中断的睡眠状态：TASK_INTERRUPTIBLE 简称S。进程正在等待某个事件的到来时，会进入此状态。这样的进程会被放入对应事件的等待队列中。当事件发生时，对应的等待队列中的一个或者多个进程就会被唤醒。
3. 不可中断的睡眠状态：TASK_UNINTERRUPTIBLE 简称D。此状态与可中断的睡眠状态唯一的区别就是不可被打断。在此状态的进程不会对任何信号做出响应。确切的说，发给此状态的进程信号直到它从改状态转出才会被传递过去。处于此状态的进程通常是等待一个特殊事件，比如等待同步的IO操作。
4. 暂停状态或者跟踪状态：TASK_STOPPED 或者 TASK_TRACED 简称T。向进程发送SIGSTOP信号，就会使该进程转入暂停状态，除非该进程正处于不可中断的睡眠状态。向正处于暂停状态的进程发送SIGCONT信号，会使该进程转向可运行状态。处于该状态的进程会暂停，并等待另一个进程（跟踪它的那个进程）对它进行操作。*用于程序调试？*
5. 僵尸状态：TASK_DEAD-EXIT_ZOMBIE 简称Z。处于此状态的进程即将结束运行，该进程占用的绝大多数资源也都已经被回收，不过还有一些信息未删除，如退出码以及一些统计信息。之所以保留这些信息主要是考虑到该进程的父进程可能需要他们。由于此时的进程被删除而只剩下一个空壳，所以才称为僵尸进程。
6. 退出状态：TASK_DEAD-EXIT_DEAD 简称X。在进程退出过程中，有可能连退出码和统计信息都不需要保留。造成这种情况的原因可能是显示的让该进程的父进程忽略掉SIGCHLD信号（当一个进程消亡的时候，内核会给其父进程发送SIGCHLD信号以告知此情况），也可能是该进程以及被分离（分离即让子进程和父进程分别独立运行）。分离后得子程序将不会再使用和执行与父进程共享的代码段中的指令。而是加载并运行一个全新的程序。在这些情况下，该进程在退出的时候就不会转入僵尸状态，而直接转入退出状态。处于退出状态的进程会立即被干净利落的结束掉，它占用的系统资源也会马上回收。


