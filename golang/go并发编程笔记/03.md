### 1. 理论基础
并发程序：允许串行程序运行在一个或多个可共享的CPU之上，同时也允许每个串行程序都运行在专门为它服务的CPU上。  
* 并发程序是指可以被同时发起执行的程序
* 并行程序则被设计成在并行的硬件上执行的并发程序
* 并发程序代表了所有可以实现并发行为的程序，包含了并行程序

并发程序的不确定性：即并发编程的混乱性  

并发程序内部的交互：同步与异步  

同步的作用是避免在并发**访问共享资源**时可能发生的冲突，以及确保有条不紊地传递数据  
同步的原则：
* 程序如果想使用一个共享资源，就必须先请求该资源并获取到对它的访问权。
* 程序不再需要某个资源的时候，它应该放弃对该资源的访问权
* 一个程序对资源的请求不应该导致其它正在访问的该资源的程序中断，而应该等到那个程序释放该资源之后再进行请求.*同一时刻，某个资源应该被一个程序占用，原子性？*

并发程序内部异步通讯：
* 异步这种方式使得数据可以不加延迟地发送给接收方。即使数据接收方还没有为接收数据做好准备，也不会造成数据发送方的等待。
* 数据会被临时存放在一个称为**通讯缓存的数据结构**中。通讯缓存时一种特殊的共享资源，它可以同时被多个程序使用。
* 数据接收方可以在准备就绪之后按照数据存入通讯缓存的顺序接收它们

### 2. 多进程编程
进程间通讯：inter-process communication  IPC  
IPC根据处理机制区分：
1. 基于通信
    * 以数据传送为手段：传送字节流的管道（pipe）和传送结构化对象的消息队列（message queue）
    * 以共享内存为手段：shared memory
2. 基于信号：操作系统的信号机制，signal，唯一异步IPC方法
3. 基于同步：信号量，semaphore

golang支持的IPC方法是管道、信号和socket  

进程的概念  
父进程和子进程，父进程使用fork来创建若干个子进程：
1. 每个子进程都是源自于它父进程的一个副本，它会获得父进程的数据段、堆和栈的副本，并与父进程共享代码段。
2. 子进程的内容是相互独立的，对副本的修改对其父进程和兄弟进程都是不可见的。*在副本创建方面，linux内核并不全盘复制父进程的数据，内核使用的是写时复制（copy on write COW）来提高进程创建的效率*
3. 刚创建的子进程也可以通过系统调用exec把一个新的程序加载到自己的内存中，原先在其内存中的数据段、堆、栈以及代码段就会欸替换掉。这样子进程执行的就是新程序

**关于linux内核处理父子进程**  
linux操作系统中的每一个进程都有父进程。所有的进程共同组成一个树状的结构。内核启动进程作为进程树的根，负责系统的初始化操作，它是所有进程的祖先，它的父进程就是自己。如果某一个进程先于它的子进程结束，那么这些子进程将会被内核启动进程收养，成为它的直接子进程。  

进程标识：
1. 进程的相关信息都会被记录在进程描述符中
2. 进程描述符不是一个简单的符号，而是一个复杂的数据结构
3. 进程ID是进程在操作系统中的唯一标识。1是内核启动进程
4. 进程id是一个非负整数且总是顺序的编号，进程id可以被重复使用。
5. 进程描述符还会包含当前进程的父进程ID，即PPID

golang可以用os代码表查看当前进程的PID和PPID
```
pid := os.Getpid()
ppid := os.Getppid()
```
