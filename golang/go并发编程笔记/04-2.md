## 调度器
### 基本结构
调度器的相关字段：
* gcwaiting：unit32，表示是否需要因一些任务而停止调度
* stopwait：int32，表示需要停止但仍未停止的P数量
* stopnote：note，用于实现与stopwait相关的事件通知机制
* sysmonwait：uint32,表示在停止调度期间系统监控任务是否在等待
* sysmonnote：note，用于实现与sysmonwait相关的事件通知机制

gcwaiting、stopwait、stopnote都是串行运行时任务执行前后的辅助协调手段。  
gcwaiting字段的值用于表示是否需要停止调度：在停止调度前，该值会被置为1；在恢复调度之前，该值会被置为0。  
一些调度任务在执行时只要发现gcwaiting为1，就会把当前P的状态置为Pgcstop，然后自减stopwait字段的值。如果发现自减后的值为0，就说明所有P的状态都已经为Pgcstop。这时候就可以历用stopnote字段，唤醒因等待调度停止而暂停的串行运行时任务了。  

sysmonwait和sysmonnote的用途类似，只是它们针对于系统监测任务。串行运行时任务执行之前，系统监测任务也需要暂停。  
sysmonwait字段，0表示未暂停，1表示已暂停。  
系统监测任务是持续执行的；确切的说，它处于无尽的循环中。  
每次迭代指出，系统监测程序就会先检查调度情况。一旦发现调度停止（gcwaiting字段的值不为0或所有P都已闲置），就会把sysmonwait字段的值设置为1，并利用sysmonnote字段暂停自身。另一方面，在恢复调度之前，调度器若发现sysmonwait字段的值不为0，就会把它置为0，并历用sysmonnote字段恢复系统监测任务的执行。  
### 一轮调度
![一轮调度总体流程](https://github.com/kin122/duoankin.github.io/blob/main/golang/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%B8%80%E8%BD%AE%E8%B0%83%E5%BA%A6%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B.png)    
总体：调度器会先从一些比较容易找到可运行G的地方入手，即：全局的（或称调度器的）可运行G队列和本地P的可运行G队列。如果从这些地方找不到可运行的G，调度程序就会进入强力查找模式。强力查找后还是无法找到任何可运行的G，则会继续查找下去。全力查找可运行G的子流程结束，就意味着当前M抢到了一个可运行的G。  
具体细节：
1. 调度器会先判断当前M是否已被锁定。M和G是可以成对的锁定在一起。
   * 锁定M和G操作可以说是为CGO准备的。CGO代表了GO中一种机制，是GO程序和C程序之间的一座桥梁，使它们的互相调用成为可能。比如C语言的函数库会用带线程本地存储技术。这些函数库会把一些数据存储在当前内核线程的私有缓存中，因此，包含了调用此类C函数库的代码的G会变得特殊。他们在特定时期内只能与同一个M产生关联，否则就会有可能失去器存储在某个内核线程的私有缓存中的数据。但是如此一来就很可能回对GO调度效率造成负面影响。所以，如果不得不进行M和G的锁定，那么一定要尽量减少锁定事件。
   * 可以通过调用runtime.LockOSThread函数，把当前的G与当时运行他的那个M锁定在一起，也可以通过调用runtime.UnlockOSThread函数接触当前G与某个M的锁定。一个M只能和一个G锁定，反之亦然。所以，如果多次调用runtime.LockOSThread函数，那么仅有最后一次调用时有效的。另一方面，即使当前的G没有与任何M锁定，调用runtime.UnlockOSThread函数也不会产生任何副作用，他只会直接返回。
2. 如果调度器在一轮调度之初发现当前M与某个G锁定，就会立即停止调度并停止当前M（或者称之为暂时阻塞）。一旦与它锁定的G处于可运行状态，就会被唤醒并继续运行那个G。停止当前G意味着相关的内核线程不能再去做其它事情。此时，调度器不必为当前M去找可运行的G。对应的，当调度器为当前M找到一个可运行的G，却发现该G已与某个M锁定，就会唤醒那个与之锁定的M以运行该G，并重新为当前M寻找可运行的G。
3. 如果调度器判断当前M未与任何G锁定，那么一轮调度的主流程就会继续进行。这时，调度器会检查是否有运行时穿行任务在等待执行（通过检查gcwaiting的值是否为0）。若有串行任务需执行则停止GO调度器（STW，stop the world），并停止阻塞当前M以等待运行时的串行任务执行完成。一旦串行任务执行完成，该M就会被唤醒，一轮调度也会再次开始。
4. 最后，如果调度器在此关于锁定和运行时串行任务的判断都为假，就会开始真正的可运行G寻找之旅。一旦找到一个可运行的G，调度器就会在判定该G未与任何M锁定之后，开始运行。

一轮调度的触发条件：
* 在用户程序启动时的一系列初始化工作之后，一轮调度流程会首次启动并使封装main函数的那个G被调度运行
* 某个G运行阻塞、结束、退出系统调用，以及其栈的增长
* 用户程序对某些标准库函数的调用也会触发一轮调度流程
* runtime.Gosched函数的调用会让当前G暂停运行，并让出CPU给其它的G，其中就包含一轮调度
* 调用runtime.Goexit函数会结束当前G运行

### 全力查找可运行的G
由runtime.findrunnable函数代表，该函数会返回一个处于Grunnable状态的G。搜索流程分2阶段10步骤
1. **获取执行终结器的G**。一个终结函数可以与一个对象关联，通过调用runtime.SetFinalizer函数就可以产生这种关联。当一个对象变为不被其他任何对象引用时，GC在回收该对象之前，就会执行与之关联的终结函数。所有终结函数的执行都会由一个专门的G负责。调度器会在判定这个专用G已完成任务之后试图获取它，然后把它置为Grunnable状态放在本地P的可运行G队列。
2. **从本地P的可运行G队列获取G**。调度器会尝试从该处获取一个G，并把它作为结果返回
3. **从调度器的可运行G队列获取G**。调度器会尝试从该处获取一个G，并把它作为结果返回
4. **从网络I/O轮询器（netpoller）处获取G**。如果netpoller已被初始化且一有过网络IO操作，那么调度器会试着从netpoller那里获取一个G列表，并把作为表头的那个G当作结果返回，同时把其余的G都放入调度器的可运行G队列。如果netpoller还未被初始化或还未有过网络IO操作，这一步跳过。此处的获取只是尝试，没有成功不会阻塞。
5. **从其它P的可运行G队列获取G**。条件允许的情况下，调度器会使用一种随机算法在全局P列表中选取P，然后试着从他们的可运行G队列中盗取（或者说转移）一般的G到本地P的可运行P队列。选取P和盗取G的过程会重复多次，成功即停止。如果成功，那么调度器会把盗取的一个G作为结果返回；否则，**搜索的第一阶段结束**
6. **获取执行GC标记任务的G**。第二阶段，调度器会先判断是否正处于GC的标记阶段，以及本地P是否可用于GC标记任务。如果都是true，调度器就会把本地P持有的GC标记专用G置为Grunnable状态并作为结果返回
7. **从调度器的可运行G队列获取G**。调度器再次尝试从该处获取一个G，并把它作为结果返回。如果依然找不到可运行的G,就会解除本地P与当前M的关联，并把该P放入调度器的空闲P列表
8. **从全局P列表的每个P的可运行G队列获取G**。遍历全局P列表中的P。并检查它们的可运行P列表。只要发现某个P的可运行G队列不是空的，就从调度器的空闲P列表中取出一个P，并在判定其可用后与当前M关联在一起，然后再返回第一阶段重新搜索可运行的G。如果所有P的可运行G队列都是空的，那就只能继续后面的搜索。
9. **获取执行GC标记任务的G**。判断是否正处于GC的标记阶段，以及与GC标记任务相关的全局资源是否可用。如果返回true，调度器就会从其空闲P列表拿出一个P。如果这个P持有一个GC标记专用G，就关联该P与当前M，然后再次执行第二阶段（返回6重新开始）
10. **从网络I/O轮询器（netpoller）处获取G**，如果netpoller已被初始化，并且有过网络IO操作，那么调度器会再次试着从netpoller那里获取一个G列表。此步骤与4的区别在于这里的获取是阻塞式，只有当netpoller那里有可用的G时，阻塞才会接触。如果此处netpoller未初始化，或者没有网络IO操作，那么就跳过。

如果上述10个步骤后，依旧没有G，则M就会停止。  

**netpoller**是GO为操作系统提供的异步IO基础组件之上，实现自己阻塞式IO写的一个子程序。  
当一个G试图在一个网络连接上进行读写操作时，底层程序就会开始为此准备，此时这个G会被迫转入Gwaiting状态。一旦准备就绪，基础组件就会返回相应的事件，这会让netpoller立即通知为此等待的G。  
因此，从netpoller处获取G的意思，就是获取那些已经接收到通知的G，调度器让他们转入Grunnable状态并等待运行。  

在第五步，调度器从其它P的可运行G队列获取G是有**先决条件**的。  
1. 出了本地P还有非空闲的P。空闲的P的可运行G队列必定为空。因此，如果除本地P之外的所有P都是空闲的，就没有必要再去它们那里偷盗G了。
2. 当前M正处于自旋状态，或者处于自旋状态的M数量小于非空闲的P数量的二分之一。此处主要为了控制自旋的M数量。

**自旋状态**，实际上是标识了M的一种工作状态。M处于自旋状态，意味着它还没有找到G来运行。无论是由于找到了可运行的G，还是由于因始终未找到G而需要停止M，当前M都会退出自旋状态。一般情况下，运行时系统中至少会有一个自旋的M，调度器会尽量保证有一个自旋的M存在。除非发现没有自旋的M，调度器是不会新启用或恢复一个M去运行新G的。一旦需要新启用或恢复一个M，它最初总是会处于自旋状态。
### 启动或停止M
相关函数：
1. **stopm()**。停止当前M的执行，直到因有新的G变得可运行而被唤醒。
2. **gcstopm()**。为串行运行时人物的执行让路，停止当前M的执行。串行运行时任务执行完毕后会被唤醒
3. **stoplockedm()**。停止已与某个G锁定的当前M的执行，直到因这个G变得可运行而被唤醒
4. **startlockedm(gp \*g)**。唤醒与gp锁定的那个M，并让该M去执行gp
5. **startm(_p_ \*p,spinning bool)**。唤醒或创建一个M去关联_p并开始执行

![启停M流程](https://github.com/kin122/duoankin.github.io/blob/main/golang/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%90%AF%E5%81%9CM%E6%B5%81%E7%A8%8B.png)  
相关流程：
1. 调度器在执行调度流程的时候，会先检查当前M时候与某个G锁定。如果锁定存在，调度器就会调用stoplockedm函数停止当前M。stoplockedm函数会先接触当前M与本地P之间的关联，并通过调用一个名为handoffp的函数把这个P转手给其它M，在这个转手P的过程中会简介调用startm函数。一旦这个P被转手，stoplockedm函数就会停止当前M的执行，并等待唤醒。
2. 另一方面，如果调度程序为当前M找到一个可运行的G，却发现该G已与某个M锁定，那么就会调用startlockedm函数并把这个G作为参数传入。startlockedm函数会通过参数gp的lockedm字段找到与之锁定的M（已锁M），并把当前M的本地P转手给它。这里的转手P的过程要比（1）中简单，startlockedm函数会先接触当前M与本地P之间的关联，然后把这个P赋给已锁M的nextp字段（即预联）
3. startlockedm函数的执行会使与其参数gp锁定的已锁M被唤醒。通过gp的lockedm字段可以找到已锁M。一旦已锁M被唤醒，就会与和它羽联的P产生正式的关联，并去执行与之关联的G。
4. startlockedm函数在最后会调用stopm函数。stopm函数会先把当前M放入调度器的空闲M列表，然后停止当前M。这里被停止的M，可能会在之后因有P需要转手，或有G需要执行而被唤醒。
   * 此处涉及两个M，一个是因等待执行与之锁定的G而停止的M；一个是获取到一个已锁定的G却不能执行的M。前者会被后者唤醒
   * 一旦M要停止就会把它的本地P转手给别的M。一旦M被唤醒，就会先找个P与之关联，即找到它的新的本地P。并且，这个P一定是在该M被唤醒之前由别的M预联给它的。因此P总是会被高效利用。如果handoffp函数无法把作为其参数的P转给一个M，那么就会把这个P放入调度器的空闲P列表。该列表中的P会在需要时被取用。
5. 调度器在执行调度流程的时候，也会检查是否有串行运行时任务正在等待执行。有的话，调度器就会调用gcstopm函数停止当前M。gcstopm函数会先通过当前M的spinning字段检查它的自旋状态，如果其值为true，则复制false，然后把调度器中用于记录自旋M数量的nmspinning字段的值减一。（完全充值了当前M的自旋状态标识）。在这之后，gcstopm函数会释放本地P，并将其状态设置为Pgcstop。然后再去自减并检查调度器的stopwait字段，并在发现stopwait字段的值为0时，通过调度器的stopnote字段唤醒等待执行的串行运行时任务。
6. gcstopm函数在最后会调用stopm函数。同样的，当前M会被放入调度器的空闲M列表并停止
   * 只要有串行运行时任务准备执行，STW就会开始，所有在调度过程的M就会执行步骤5和6.其中5决定了串行运行时任务是否能够被尽早的执行。
7. 调度不成功的时候。如果经历完整的一轮调度后，找不到可运行的G给当前M执行，那么调度程序就会通过调用stopm函数停止当前的M。停止的M被唤醒，则是已经有预联的P。不过也有一种情况，stopm函数发现当前M是因为并发执行的GC任务被唤醒，那么就有可能执行完该任务后再次停止当前M
8. 所有经由调用stopm函数停止的M，都可以通过startm函数唤醒。有时候，传入startm函数的参数_p_为nil，这就说明在唤醒一个M的同时，需要从调度器的空闲P列表获取一个P作为M运行G的上下文环境。如果这个列表已经空了，那么startm函数也就无能为力了（没有上下文环境有了M也没有用），这是startm函数会直接返回。一旦有了一个P，startm函数就会再从调度器的空闲M列表获取一个M；如果该列表已空就创建一个新的M。无论如何，startm函数都会把拿到的P和这个M预联，然后让该M做好执行准备。
  
### 系统监测任务
主要由sysmon函数实现。  
系统检测任务主要做了如下几件事：
* 在需要时抢夺符合条件的P和G
* 在需要时进行强制GC
* 在需要时清扫堆
* 在需要时打印调度器跟踪信息

其循环的特性：
1. 监测任务被包裹在一个循环之中，被一次次的执行
2. 变量idle和delay的值决定了每个监测任务执行之初的睡眠时间，这也是执行间隔的主要体现。
   * idle代表最近已连续有多少次监测任务执行但未能成功夺取P，一旦某次执行过程中成功夺取P，其值就会被清零。
   * delay代表睡眠的具体时间，单位是微秒，最大值是10000
   * 睡醒过后，监测任务还会因GC的执行或所有P的空闲暂停一段时间，这段时间的长短取决于局部变量forcegcperiod和scavengelimit

**抢夺P和G的途径**  
1. 通过网络IO轮询器获取可运行的G，此处有个前提条件，自上次通过该途径获取G是否超过10ms，如果已经超过，则记录下当前时间以供下次判断，然后再次获取。否则再次获取
2. 从调度器抢夺符合条件的P和G  
   * 由runtime中retake函数实现,首先检查P的状态
   * 如果该P的状态为Psyscall，程序就会检查它的**系统调用计数**是否同步。一个P所经历的系统调用的次数被记录在它的syscalltick字段中。系统监测程序也会持有一个备份，它存在用于描述该P的结构体对象的syycalltick字段中。因此，这里的同步就是指这两个数是否相同：如果不同，程序就更新这个备份，然后忽略对该P的进一步检查；如果相同，就再判断后续的那三个条件，做这些条件判断的目的是确定是否真的有必要抢夺该P。该P中的可运行G一定会被它们搜索到，无需系统监测程序查收。若最终检查收确认该P满足抢夺的条件，程序就会在递增相关计数后，把该P抢夺过来并转其它M。
   * 判断距上次同步该P的系统调用时间是否不足10ms用到了该P的描述对象的syscallwhen字段，该字段的值会在系统调用计数不同步时被更新为now
   * 如果该P的状态为Prunning，程序就会检查他的**调度计数**是否同步。P的调度计数又他的schedtick字段存储，只要它的可运行G队列中的某个G被取出运行了，该字段的值就会递增。同样的，系统监测程序也会持有一个调度计数的备份，由该P的描述对象的schedtick字段值代表。如果这个备份与该P的schedtick字段值不同，程序就更新这个备份，同时把该P的描述对象的schedwhen字段值更新为now，然后忽略对该P的进一步检查。如果相同，就判断据上一次同步该P的调度时间是否不足10ms，这个调度时间正是由那个schedwhen字段值代表的。如果这里的判断为false，就说明该P的G已经运行了太长时间，需要停止并把运行机会让给其它G，这也是为了保证公平。
   * 不过即使有一个G运行了太长时间，系统监测程序也因此告知它需要停止，它也不一定会停止。且不说这个告知不一定能够被正确的传递给这个G,就算这个G及时的接收到了告知，也可能会将其忽略掉。因此，系统监测程序仅会也仅能履行告知义务，而即不保证告知的正确达到，也不保证那个G会做出响应。


**GC和清扫堆**  
专用于强制GC的G，其实在调度器初始化时就已经开始运行了，只不过他一般会处于暂停状态，只有系统监测程序可以恢复它。一旦判定GC当前未执行，且距上一次执行已超过GC最大间隔时间，系统监测程序就会恢复这个专用G，把它放入调度器的可运行G队列。GC最大间隔时间由forcegcperiod变量代表，其初始值为2min。  
清扫堆的工作仅在上一次执行已超时清扫堆间隔时间时才会执行，而清扫堆的任务是把一段时间内未用的堆内存还给操作系统。清扫堆间隔时间与scavengelimit变量有关，为它所代表时间的一半。scavengelimit的初始值为5min。  
设置环境变量GODEBUG可以缩短强制GC和清扫堆的间隔时间，设置scavenge=1，可以使得scavengelimit的值变为20ms，forcegcperiod的值为10ms。但是这相当于开启了GC的调试模式，不可在生产使用。  

**打印调度器跟踪信息**  
受当前操作系统的环境变量GODEBUG控制，设置环境变量的值并使用包含schedtrace=X，则系统监测程序就会适时地向标准输出打印调度器跟踪信息，这里X代表多少毫秒打印一次信息。

### 变更P的最大数量
P最大数量的变更意味着要改变G运行的上下文环境。默认情况下，P的最大数量等于正在运行当前GO程序的逻辑CPU。  
P的最大值runtime.GOMAXPROCS设定或者调用时会校验最大值的合理性（上限和是否正确，不为负等）  
在变更P的最大数量时：
1. 检查runtime.GOMAXPROCS的合法性
2. STW，暂存新值、重启调度工作

具体细节：  
1. runtime包中procresize函数实现
2. 旧值也会被获取。如果发现旧值或者新值不合法，程序就会发起一个运行时恐慌，流程和程序也都会随即终止。由于runtime.GOMAXPROCS函数已经做过检查，此流程也不会被执行。
3. 通过对新旧值得检查后，程序就会对全局P列表得前I个P进行检查和必要的初始化。这里的I代表新值。如果全局的P列表的P数量不够，程序还会新建相应数量的P，并把它们追加到全局P列表中。新P的状态为Pgcstop，以表示他还不能使用。
4. 全局P列表中所有P的可运行G队列的固定长度都会是256.如果队列满了，程序就会把其中半数的可运行G转移到调度器的可运行G队列中。
5. 完成对前I个P的重新设置之后，程序会对全局P列表中的第I+1个至第J个P进行清理。这里的J代表旧值。其中，最重要的工作就是把这些P的可运行G队列中的G及其润next字段中的G全部取出，并以此放入调度器的可运行G队列中。
6. 程序也会试图获取这些P持有的GC标记专用G，若取到，就放入调度器的可运行G队列。
7. 程序还会把这些P的自由G列表中的所有G，都转移到调度器的自由G列表中。
8. 最后，这些P都被设置为Pdead状态，以便以后进行销毁，之所以现在不能直接销毁，因为它们可能会被正在进行系统调用的M使用，马上销毁会造成错误。
9. 此时，全局P列表中所有的O都已经被重新设置，也包括了与执行procresize函数的当前M关联的那个P。由于当前M不能没有P，所以程序会试图把该M之前的P换给它，若发现那个P已经被清理，就把全局P列表中的第一个P给它
10. 最后的最后，程序会再检查一遍前N个P，如果它的可运行G队列为空，就把它放入调度器的空闲P列表，否则就试图拿一个M与之绑定，然后把它放入本地的可运行P列表。这样筛选出一个拥有可运行G的P的列表，procresize函数会把这个列表作为结果值返回。负责重启调度工作的程序会检查这个列表中的P，以保证它们一定能与一个M产生关联，随手程序会让这些P关联的M都运作起来。

