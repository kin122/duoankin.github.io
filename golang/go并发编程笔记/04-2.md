## 调度器
### 基本结构
调度器的相关字段：
* gcwaiting：unit32，表示是否需要因一些任务而停止调度
* stopwait：int32，表示需要停止但仍未停止的P数量
* stopnote：note，用于实现与stopwait相关的事件通知机制
* sysmonwait：uint32,表示在停止调度期间系统监控任务是否在等待
* sysmonnote：note，用于实现与sysmonwait相关的事件通知机制

gcwaiting、stopwait、stopnote都是串行运行时任务执行前后的辅助协调手段。  
gcwaiting字段的值用于表示是否需要停止调度：在停止调度前，该值会被置为1；在恢复调度之前，该值会被置为0。  
一些调度任务在执行时只要发现gcwaiting为1，就会把当前P的状态置为Pgcstop，然后自减stopwait字段的值。如果发现自减后的值为0，就说明所有P的状态都已经为Pgcstop。这时候就可以历用stopnote字段，唤醒因等待调度停止而暂停的串行运行时任务了。  

sysmonwait和sysmonnote的用途类似，只是它们针对于系统监测任务。串行运行时任务执行之前，系统监测任务也需要暂停。  
sysmonwait字段，0表示未暂停，1表示已暂停。  
系统监测任务是持续执行的；确切的说，它处于无尽的循环中。  
每次迭代指出，系统监测程序就会先检查调度情况。一旦发现调度停止（gcwaiting字段的值不为0或所有P都已闲置），就会把sysmonwait字段的值设置为1，并利用sysmonnote字段暂停自身。另一方面，在恢复调度之前，调度器若发现sysmonwait字段的值不为0，就会把它置为0，并历用sysmonnote字段恢复系统监测任务的执行。  
### 一轮调度
### 全力查找可运行的G
1. 获取执行终结器的G
2. 从本地P的可运行G队列获取G
3. 从调度器的可运行G队列获取G
4. 从网络I/O轮询器（netpoller）处获取G
5. 从其它P的可运行G队列获取G
6. 获取执行GC标记任务的G
7. 从调度器的可运行G队列获取G
8. 从全局P列表的每个P的可运行G队列获取G
9. 获取执行GC标记任务的G
10. 从网络I/O轮询器（netpoller）处获取G（阻塞式获取）
### 启动或停止M
相关函数：
1. stopm()
2. gcstopm()
3. stoplockedm()
4. startlockedm()
5. startm(_p_ \*p,spinning bool)
### 系统监测任务
系统检测任务主要做了如下几件事：
* 在需要时抢夺符合条件的P和G
* 在需要时进行强制GC
* 在需要时清扫堆
* 在需要时打印调度器跟踪信息
### 变更P的最大数量
