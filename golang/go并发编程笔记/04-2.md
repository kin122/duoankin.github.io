## 调度器
### 基本结构
调度器的相关字段：
* gcwaiting：unit32，表示是否需要因一些任务而停止调度
* stopwait：int32，表示需要停止但仍未停止的P数量
* stopnote：note，用于实现与stopwait相关的事件通知机制
* sysmonwait：uint32,表示在停止调度期间系统监控任务是否在等待
* sysmonnote：note，用于实现与sysmonwait相关的事件通知机制

gcwaiting、stopwait、stopnote都是串行运行时任务执行前后的辅助协调手段。  
gcwaiting字段的值用于表示是否需要停止调度：在停止调度前，该值会被置为1；在恢复调度之前，该值会被置为0。  
一些调度任务在执行时只要发现gcwaiting为1，就会把当前P的状态置为Pgcstop，然后自减stopwait字段的值。如果发现自减后的值为0，就说明所有P的状态都已经为Pgcstop。这时候就可以历用stopnote字段，唤醒因等待调度停止而暂停的串行运行时任务了。  

sysmonwait和sysmonnote的用途类似，只是它们针对于系统监测任务。串行运行时任务执行之前，系统监测任务也需要暂停。  
sysmonwait字段，0表示未暂停，1表示已暂停。  
系统监测任务是持续执行的；确切的说，它处于无尽的循环中。  
每次迭代指出，系统监测程序就会先检查调度情况。一旦发现调度停止（gcwaiting字段的值不为0或所有P都已闲置），就会把sysmonwait字段的值设置为1，并利用sysmonnote字段暂停自身。另一方面，在恢复调度之前，调度器若发现sysmonwait字段的值不为0，就会把它置为0，并历用sysmonnote字段恢复系统监测任务的执行。  
### 一轮调度
*图待补充*  
总体：调度器会先从一些比较容易找到可运行G的地方入手，即：全局的（或称调度器的）可运行G队列和本地P的可运行G队列。如果从这些地方找不到可运行的G，调度程序就会进入强力查找模式。强力查找后还是无法找到任何可运行的G，则会继续查找下去。全力查找可运行G的子流程结束，就意味着当前M抢到了一个可运行的G。  
具体细节：
1. 调度器会先判断当前M是否已被锁定。M和G是可以成对的锁定在一起。
   * 锁定M和G操作可以说是为CGO准备的。CGO代表了GO中一种机制，是GO程序和C程序之间的一座桥梁，使它们的互相调用成为可能。比如C语言的函数库会用带线程本地存储技术。这些函数库会把一些数据存储在当前内核线程的私有缓存中，因此，包含了调用此类C函数库的代码的G会变得特殊。他们在特定时期内只能与同一个M产生关联，否则就会有可能失去器存储在某个内核线程的私有缓存中的数据。但是如此一来就很可能回对GO调度效率造成负面影响。所以，如果不得不进行M和G的锁定，那么一定要尽量减少锁定事件。
   * 可以通过调用runtime.LockOSThread函数，把当前的G与当时运行他的那个M锁定在一起，也可以通过调用runtime.UnlockOSThread函数接触当前G与某个M的锁定。一个M只能和一个G锁定，反之亦然。所以，如果多次调用runtime.LockOSThread函数，那么仅有最后一次调用时有效的。另一方面，即使当前的G没有与任何M锁定，调用runtime.UnlockOSThread函数也不会产生任何副作用，他只会直接返回。
2. 如果调度器在一轮调度之初发现当前M与某个G锁定，就会立即停止调度并停止当前M（或者称之为暂时阻塞）。一旦与它锁定的G处于可运行状态，就会被唤醒并继续运行那个G。停止当前G意味着相关的内核线程不能再去做其它事情。此时，调度器不必为当前M去找可运行的G。对应的，当调度器为当前M找到一个可运行的G，却发现该G已与某个M锁定，就会唤醒那个与之锁定的M以运行该G，并重新为当前M寻找可运行的G。
3. 如果调度器判断当前M未与任何G锁定，那么一轮调度的主流程就会继续进行。这时，调度器会检查是否有运行时穿行任务在等待执行（通过检查gcwaiting的值是否为0）。若有串行任务需执行则停止GO调度器（STW，stop the world），并停止阻塞当前M以等待运行时的串行任务执行完成。一旦串行任务执行完成，该M就会被唤醒，一轮调度也会再次开始。
4. 最后，如果调度器在此关于锁定和运行时串行任务的判断都为假，就会开始真正的可运行G寻找之旅。一旦找到一个可运行的G，调度器就会在判定该G未与任何M锁定之后，开始运行。

一轮调度的触发条件：
* 在用户程序启动时的一系列初始化工作之后，一轮调度流程会首次启动并使封装main函数的那个G被调度运行
* 某个G运行阻塞、结束、退出系统调用，以及其栈的增长
* 用户程序对某些标准库函数的调用也会触发一轮调度流程
* runtime.Gosched函数的调用会让当前G暂停运行，并让出CPU给其它的G，其中就包含一轮调度
* 调用runtime.Goexit函数会结束当前G运行

### 全力查找可运行的G
由runtime.findrunnable函数代表，该函数会返回一个处于Grunnable状态的G。搜索流程分2阶段10步骤
1. **获取执行终结器的G**。一个终结函数可以与一个对象关联，通过调用runtime.SetFinalizer函数就可以产生这种关联。当一个对象变为不被其他任何对象引用时，GC在回收该对象之前，就会执行与之关联的终结函数。所有终结函数的执行都会由一个专门的G负责。调度器会在判定这个专用G已完成任务之后试图获取它，然后把它置为Grunnable状态放在本地P的可运行G队列。
2. **从本地P的可运行G队列获取G**。调度器会尝试从该处获取一个G，并把它作为结果返回
3. **从调度器的可运行G队列获取G**。调度器会尝试从该处获取一个G，并把它作为结果返回
4. **从网络I/O轮询器（netpoller）处获取G**。如果netpoller已被初始化且一有过网络IO操作，那么调度器会试着从netpoller那里获取一个G列表，并把作为表头的那个G当作结果返回，同时把其余的G都放入调度器的可运行G队列。如果netpoller还未被初始化或还未有过网络IO操作，这一步跳过。此处的获取只是尝试，没有成功不会阻塞。
5. **从其它P的可运行G队列获取G**。条件允许的情况下，调度器会使用一种随机算法在全局P列表中选取P，然后试着从他们的可运行G队列中盗取（或者说转移）一般的G到本地P的可运行P队列。选取P和盗取G的过程会重复多次，成功即停止。如果成功，那么调度器会把盗取的一个G作为结果返回；否则，**搜索的第一阶段结束**
6. **获取执行GC标记任务的G**。第二阶段，调度器会先判断是否正处于GC的标记阶段，以及本地P是否可用于GC标记任务。如果都是true，调度器就会把本地P持有的GC标记专用G置为Grunnable状态并作为结果返回
7. **从调度器的可运行G队列获取G**。调度器再次尝试从该处获取一个G，并把它作为结果返回。如果依然找不到可运行的G,就会解除本地P与当前M的关联，并把该P放入调度器的空闲P列表
8. **从全局P列表的每个P的可运行G队列获取G**。遍历全局P列表中的P。并检查它们的可运行P列表。只要发现某个P的可运行G队列不是空的，就从调度器的空闲P列表中取出一个P，并在判定其可用后与当前M关联在一起，然后再返回第一阶段重新搜索可运行的G。如果所有P的可运行G队列都是空的，那就只能继续后面的搜索。
9. **获取执行GC标记任务的G**。判断是否正处于GC的标记阶段，以及与GC标记任务相关的全局资源是否可用。如果返回true，调度器就会从其空闲P列表拿出一个P。如果这个P持有一个GC标记专用G，就关联该P与当前M，然后再次执行第二阶段（返回6重新开始）
10. **从网络I/O轮询器（netpoller）处获取G**，如果netpoller已被初始化，并且有过网络IO操作，那么调度器会再次试着从netpoller那里获取一个G列表。此步骤与4的区别在于这里的获取是阻塞式，只有当netpoller那里有可用的G时，阻塞才会接触。如果此处netpoller未初始化，或者没有网络IO操作，那么就跳过。

如果上述10个步骤后，依旧没有G，则M就会停止。  

**netpoller**是GO为操作系统提供的异步IO基础组件之上，实现自己阻塞式IO写的一个子程序。  
当一个G试图在一个网络连接上进行读写操作时，底层程序就会开始为此准备，此时这个G会被迫转入Gwaiting状态。一旦准备就绪，基础组件就会返回相应的事件，这会让netpoller立即通知为此等待的G。  
因此，从netpoller处获取G的意思，就是获取那些已经接收到通知的G，调度器让他们转入Grunnable状态并等待运行。  

在第五步，调度器从其它P的可运行G队列获取G是有**先决条件**的。  
1. 出了本地P还有非空闲的P。空闲的P的可运行G队列必定为空。因此，如果除本地P之外的所有P都是空闲的，就没有必要再去它们那里偷盗G了。
2. 当前M正处于自旋状态，或者处于自旋状态的M数量小于非空闲的P数量的二分之一。此处主要为了控制自旋的M数量。

**自旋状态**，实际上是标识了M的一种工作状态。M处于自旋状态，意味着它还没有找到G来运行。无论是由于找到了可运行的G，还是由于因始终未找到G而需要停止M，当前M都会退出自旋状态。一般情况下，运行时系统中至少会有一个自旋的M，调度器会尽量保证有一个自旋的M存在。除非发现没有自旋的M，调度器是不会新启用或恢复一个M去运行新G的。一旦需要新启用或恢复一个M，它最初总是会处于自旋状态。
### 启动或停止M
相关函数：
1. **stopm()**。停止当前M的执行，直到因有新的G变得可运行而被唤醒。
2. **gcstopm()**。为串行运行时人物的执行让路，停止当前M的执行。串行运行时任务执行完毕后会被唤醒
3. **stoplockedm()**。停止已与某个G锁定的当前M的执行，直到因这个G变得可运行而被唤醒
4. **startlockedm(gp \*g)**。唤醒与gp锁定的那个M，并让该M去执行gp
5. **startm(_p_ \*p,spinning bool)**。唤醒或创建一个M去关联_p并开始执行

*go启停M的流程图*  
相关流程：
1. 调度器在执行调度流程的时候，会先检查当前M时候与某个G锁定。如果锁定存在，调度器就会调用stoplockedm函数停止当前M。stoplockedm函数会先接触当前M与本地P之间的关联，并通过调用一个名为handoffp的函数把这个P转手给其它M，在这个转手P的过程中会简介调用startm函数。一旦这个P被转手，stoplockedm函数就会停止当前M的执行，并等待唤醒。
2. 另一方面，如果调度程序为当前M找到一个可运行的G，却发现该G已与某个M锁定，那么就会调用startlockedm函数并把这个G作为参数传入。startlockedm函数会通过参数gp的lockedm字段找到与之锁定的M（已锁M），并把当前M的本地P转手给它。这里的转手P的过程要比（1）中简单，startlockedm函数会先接触当前M与本地P之间的关联，然后把这个P赋给已锁M的nextp字段（即预联）
3. startlockedm函数的执行会使与其参数gp锁定的已锁M被唤醒。通过gp的lockedm字段可以找到已锁M。一旦已锁M被唤醒，就会与和它羽联的P产生正式的关联，并去执行与之关联的G。
4. startlockedm函数在最后会调用stopm函数。stopm函数会先把当前M放入调度器的空闲M列表，然后停止当前M。这里被停止的M，可能会在之后因有P需要转手，或有G需要执行而被唤醒。
   * 此处涉及两个M，一个是因等待执行与之锁定的G而停止的M；一个是获取到一个已锁定的G却不能执行的M。前者会被后者唤醒
   * 一旦M要停止就会把它的本地P转手给别的M。一旦M被唤醒，就会先找个P与之关联，即找到它的新的本地P。并且，这个P一定是在该M被唤醒之前由别的M预联给它的。因此P总是会被高效利用。如果handoffp函数无法把作为其参数的P转给一个M，那么就会把这个P放入调度器的空闲P列表。该列表中的P会在需要时被取用。
5. 调度器在执行调度流程的时候，也会检查是否有串行运行时任务正在等待执行。有的话，调度器就会调用gcstopm函数停止当前M。gcstopm函数会先通过当前M的spinning字段检查它的自旋状态，如果其值为true，则复制false，然后把调度器中用于记录自旋M数量的nmspinning字段的值减一。（完全充值了当前M的自旋状态标识）。在这之后，gcstopm函数会释放本地P，并将其状态设置为Pgcstop。然后再去自减并检查调度器的stopwait字段，并在发现stopwait字段的值为0时，通过调度器的stopnote字段唤醒等待执行的串行运行时任务。
6. gcstopm函数在最后会调用stopm函数。同样的，当前M会被放入调度器的空闲M列表并停止
   * 只要有串行运行时任务准备执行，STW就会开始，所有在调度过程的M就会执行步骤5和6.其中5决定了串行运行时任务是否能够被尽早的执行。
7. 调度不成功的时候。如果经历完整的一轮调度后，找不到可运行的G给当前M执行，那么调度程序就会通过调用stopm函数停止当前的M。停止的M被唤醒，则是已经有预联的P。不过也有一种情况，stopm函数发现当前M是因为并发执行的GC任务被唤醒，那么就有可能执行完该任务后再次停止当前M
8. 所有经由调用stopm函数停止的M，都可以通过startm函数唤醒。有时候，传入startm函数的参数_p_为nil，这就说明在唤醒一个M的同时，需要从调度器的空闲P列表获取一个P作为M运行G的上下文环境。如果这个列表已经空了，那么startm函数也就无能为力了（没有上下文环境有了M也没有用），这是startm函数会直接返回。一旦有了一个P，startm函数就会再从调度器的空闲M列表获取一个M；如果该列表已空就创建一个新的M。无论如何，startm函数都会把拿到的P和这个M预联，然后让该M做好执行准备。
  
### 系统监测任务
主要由sysmon函数实现。  
*系统监测任务总体流程图*
系统检测任务主要做了如下几件事：
* 在需要时抢夺符合条件的P和G
* 在需要时进行强制GC
* 在需要时清扫堆
* 在需要时打印调度器跟踪信息

其循环的特性：
1. 监测任务被包裹在一个循环之中，被一次次的执行
2. 变量idle和delay的值决定了每个监测任务执行之初的睡眠时间，这也是执行间隔的主要体现。
   * idle代表最近已连续有多少次监测任务执行但未能成功夺取P，一旦某次执行过程中成功夺取P，其值就会被清零。
   * delay代表睡眠的具体时间，单位是微秒，最大值是10000
   * 睡醒过后，监测任务还会因GC的执行或所有P的空闲暂停一段时间，这段时间的长短取决于局部变量forcegcperiod和scavengelimit

**抢夺P和G的途径**  
**GC和清扫堆**  
**打印调度器跟踪信息**  

### 变更P的最大数量
P最大数量的变更意味着要改变G运行的上下文环境。默认情况下，P的最大数量等于正在运行当前GO程序的逻辑CPU。  
P的最大值runtime.GOMAXPROCS设定或者调用时会校验最大值的合理性（上限和是否正确，不为负等）  
在变更P的最大数量时：
1. 检查runtime.GOMAXPROCS的合法性
2. STW，暂存新值、重启调度工作

具体细节：
*图-变更P最大数量的核心流程*  
1.
2.
3.
4.
