## 调度器
### 基本结构
调度器的相关字段：
* gcwaiting：unit32，表示是否需要因一些任务而停止调度
* stopwait：int32，表示需要停止但仍未停止的P数量
* stopnote：note，用于实现与stopwait相关的事件通知机制
* sysmonwait：uint32,表示在停止调度期间系统监控任务是否在等待
* sysmonnote：note，用于实现与sysmonwait相关的事件通知机制

gcwaiting、stopwait、stopnote都是串行运行时任务执行前后的辅助协调手段。  
gcwaiting字段的值用于表示是否需要停止调度：在停止调度前，该值会被置为1；在恢复调度之前，该值会被置为0。  
一些调度任务在执行时只要发现gcwaiting为1，就会把当前P的状态置为Pgcstop，然后自减stopwait字段的值。如果发现自减后的值为0，就说明所有P的状态都已经为Pgcstop。这时候就可以历用stopnote字段，唤醒因等待调度停止而暂停的串行运行时任务了。  

sysmonwait和sysmonnote的用途类似，只是它们针对于系统监测任务。串行运行时任务执行之前，系统监测任务也需要暂停。  
sysmonwait字段，0表示未暂停，1表示已暂停。  
系统监测任务是持续执行的；确切的说，它处于无尽的循环中。  
每次迭代指出，系统监测程序就会先检查调度情况。一旦发现调度停止（gcwaiting字段的值不为0或所有P都已闲置），就会把sysmonwait字段的值设置为1，并利用sysmonnote字段暂停自身。另一方面，在恢复调度之前，调度器若发现sysmonwait字段的值不为0，就会把它置为0，并历用sysmonnote字段恢复系统监测任务的执行。  
### 一轮调度
*图待补充*  
总体：调度器会先从一些比较容易找到可运行G的地方入手，即：全局的（或称调度器的）可运行G队列和本地P的可运行G队列。如果从这些地方找不到可运行的G，调度程序就会进入强力查找模式。强力查找后还是无法找到任何可运行的G，则会继续查找下去。全力查找可运行G的子流程结束，就意味着当前M抢到了一个可运行的G。  
具体细节：
1. 调度器会先判断当前M是否已被锁定。M和G是可以成对的锁定在一起。
   * 锁定M和G操作可以说是为CGO准备的。CGO代表了GO中一种机制，是GO程序和C程序之间的一座桥梁，使它们的互相调用成为可能。比如C语言的函数库会用带线程本地存储技术。这些函数库会把一些数据存储在当前内核线程的私有缓存中，因此，包含了调用此类C函数库的代码的G会变得特殊。他们在特定时期内只能与同一个M产生关联，否则就会有可能失去器存储在某个内核线程的私有缓存中的数据。但是如此一来就很可能回对GO调度效率造成负面影响。所以，如果不得不进行M和G的锁定，那么一定要尽量减少锁定事件。
   * 可以通过调用runtime.LockOSThread函数，把当前的G与当时运行他的那个M锁定在一起，也可以通过调用runtime.UnlockOSThread函数接触当前G与某个M的锁定。一个M只能和一个G锁定，反之亦然。所以，如果多次调用runtime.LockOSThread函数，那么仅有最后一次调用时有效的。另一方面，即使当前的G没有与任何M锁定，调用runtime.UnlockOSThread函数也不会产生任何副作用，他只会直接返回。
2. 如果调度器在一轮调度之初发现当前M与某个G锁定，就会立即停止调度并停止当前M（或者称之为暂时阻塞）。一旦与它锁定的G处于可运行状态，就会被唤醒并继续运行那个G。停止当前G意味着相关的内核线程不能再去做其它事情。此时，调度器不必为当前M去找可运行的G。对应的，当调度器为当前M找到一个可运行的G，却发现该G已与某个M锁定，就会唤醒那个与之锁定的M以运行该G，并重新为当前M寻找可运行的G。
3. 如果调度器判断当前M未与任何G锁定，那么一轮调度的主流程就会继续进行。这时，调度器会检查是否有运行时穿行任务在等待执行（通过检查gcwaiting的值是否为0）。若有串行任务需执行则停止GO调度器（STW，stop the world），并停止阻塞当前M以等待运行时的串行任务执行完成。一旦串行任务执行完成，该M就会被唤醒，一轮调度也会再次开始。
4. 最后，如果调度器在此关于锁定和运行时串行任务的判断都为假，就会开始真正的可运行G寻找之旅。一旦找到一个可运行的G，调度器就会在判定该G未与任何M锁定之后，开始运行。

一轮调度的触发条件：
* 在用户程序启动时的一系列初始化工作之后，一轮调度流程会首次启动并使封装main函数的那个G被调度运行
* 某个G运行阻塞、结束、退出系统调用，以及其栈的增长
* 用户程序对某些标准库函数的调用也会触发一轮调度流程
* runtime.Gosched函数的调用会让当前G暂停运行，并让出CPU给其它的G，其中就包含一轮调度
* 调用runtime.Goexit函数会结束当前G运行

### 全力查找可运行的G
由runtime.findrunnable函数代表，该函数会返回一个处于Grunnable状态的G。搜索流程分2阶段10步骤
1. **获取执行终结器的G**。一个终结函数可以与一个对象关联，通过调用runtime.SetFinalizer函数就可以产生这种关联。当一个对象变为不被其他任何对象引用时，GC在回收该对象之前，就会执行与之关联的终结函数。所有终结函数的执行都会由一个专门的G负责。调度器会在判定这个专用G已完成任务之后试图获取它，然后把它置为Grunnable状态放在本地P的可运行G队列。
2. **从本地P的可运行G队列获取G**。调度器会尝试从该处获取一个G，并把它作为结果返回
3. **从调度器的可运行G队列获取G**。调度器会尝试从该处获取一个G，并把它作为结果返回
4. **从网络I/O轮询器（netpoller）处获取G**。如果netpoller已被初始化且一有过网络IO操作，那么调度器会试着从netpoller那里获取一个G列表，并把作为表头的那个G当作结果返回，同时把其余的G都放入调度器的可运行G队列。如果netpoller还未被初始化或还未有过网络IO操作，这一步跳过。此处的获取只是尝试，没有成功不会阻塞。
5. **从其它P的可运行G队列获取G**。条件允许的情况下，调度器会使用一种随机算法在全局P列表中选取P，然后试着从他们的可运行G队列中盗取（或者说转移）一般的G到本地P的可运行P队列。选取P和盗取G的过程会重复多次，成功即停止。如果成功，那么调度器会把盗取的一个G作为结果返回；否则，**搜索的第一阶段结束**
6. **获取执行GC标记任务的G**。第二阶段，调度器会先判断是否正处于GC的标记阶段，以及本地P是否可用于GC标记任务。如果都是true，调度器就会把本地P持有的GC标记专用G置为Grunnable状态并作为结果返回
7. **从调度器的可运行G队列获取G**。调度器再次尝试从该处获取一个G，并把它作为结果返回。如果依然找不到可运行的G,就会解除本地P与当前M的关联，并把该P放入调度器的空闲P列表
8. **从全局P列表的每个P的可运行G队列获取G**。遍历全局P列表中的P。并检查它们的可运行P列表。只要发现某个P的可运行G队列不是空的，就从调度器的空闲P列表中取出一个P，并在判定其可用后与当前M关联在一起，然后再返回第一阶段重新搜索可运行的G。如果所有P的可运行G队列都是空的，那就只能继续后面的搜索。
9. **获取执行GC标记任务的G**。判断是否正处于GC的标记阶段，以及与GC标记任务相关的全局资源是否可用。如果返回true，调度器就会从其空闲P列表拿出一个P。如果这个P持有一个GC标记专用G，就关联该P与当前M，然后再次执行第二阶段（返回6重新开始）
10. **从网络I/O轮询器（netpoller）处获取G**，如果netpoller已被初始化，并且有过网络IO操作，那么调度器会再次试着从netpoller那里获取一个G列表。此步骤与4的区别在于这里的获取是阻塞式，只有当netpoller那里有可用的G时，阻塞才会接触。如果此处netpoller未初始化，或者没有网络IO操作，那么就跳过。

如果上述10个步骤后，依旧没有G，则M就会停止。  

**netpoller**是GO为操作系统提供的异步IO基础组件之上，实现自己阻塞式IO写的一个子程序。  
当一个G试图在一个网络连接上进行读写操作时，底层程序就会开始为此准备，此时这个G会被迫转入Gwaiting状态。一旦准备就绪，基础组件就会返回相应的事件，这会让netpoller立即通知为此等待的G。  
因此，从netpoller处获取G的意思，就是获取那些已经接收到通知的G，调度器让他们转入Grunnable状态并等待运行。  

在第五步，调度器从其它P的可运行G队列获取G是有**先决条件**的。  
1. 出了本地P还有非空闲的P。空闲的P的可运行G队列必定为空。因此，如果除本地P之外的所有P都是空闲的，就没有必要再去它们那里偷盗G了。
2. 当前M正处于自旋状态，或者处于自旋状态的M数量小于非空闲的P数量的二分之一。此处主要为了控制自旋的M数量。

**自旋状态**，实际上是标识了M的一种工作状态。M处于自旋状态，意味着它还没有找到G来运行。无论是由于找到了可运行的G，还是由于因始终未找到G而需要停止M，当前M都会退出自旋状态。一般情况下，运行时系统中至少会有一个自旋的M，调度器会尽量保证有一个自旋的M存在。除非发现没有自旋的M，调度器是不会新启用或恢复一个M去运行新G的。一旦需要新启用或恢复一个M，它最初总是会处于自旋状态。
### 启动或停止M
相关函数：
1. stopm()
2. gcstopm()
3. stoplockedm()
4. startlockedm()
5. startm(_p_ \*p,spinning bool)
### 系统监测任务
系统检测任务主要做了如下几件事：
* 在需要时抢夺符合条件的P和G
* 在需要时进行强制GC
* 在需要时清扫堆
* 在需要时打印调度器跟踪信息
### 变更P的最大数量
