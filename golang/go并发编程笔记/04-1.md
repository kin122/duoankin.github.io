goroutine:不要用共享内存的方式来通讯。作为替代，应该以通信作为手段来共享内存。  
GO的并发机制指的是用于支撑goroutine和channel的底层原理。**此处的原理主要包含在runtime的代码包**  

### 线程实现模型
* M：machine的缩写。一个M代表一个内核线程，或称为“工作线程”
* P：processor得缩写。一个P代表执行一个GO代码片段所必须的资源
* G：goroutine的缩写。一个G代表一个GO代码片段，前者是对后者的一种封装

简单的环境描述：  
一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境）。**每个P都会包含一个可运行的G的队列（runq）**。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。在这里我们把运行当前G的那个M称为“当前M”，并把与当前M关联的那个P称为“本地P”。  

M/P/G与内核调度实体（KSE）的关系： 
1. GO的运行时系统（runtime system）用M代表一个内核调度实体。
2. M与KSE之间的关联非常稳固，一个M在其生命周期内，会且仅会与一个KSE产生关联。即**M与KSE之间总是一对一的关系，一个M能且仅能代表一个内核线程**。
3. 相比之下，M与P、P与G之间的关联都是易变的。它们之间的对应关系会在实际调度中根据情况改变。
4. **M与P之间的关系也总是一对一的，而P与G之间的关系则是一对多的。**
5. 一个G终归会由一个M来负责运行，它们之间的关联会由P来牵线。

#### 关于M（工作线程）
关于M的创建时机（M的个数随着需求增加，并非运行一开始固定）：
* 大多数情况下，创建一个M，都是由于没有足够的M来关联P并运行其中可运行的G。
* 系统执行系统监控或垃圾回收等任务的时候，也会导致新的M创建。

M结构：
```
type m struct{
go *g           //是一个特殊的goroutine字段，是GO运行时系统在启动之初创建的，用于执行一些运行时的任务  
mstartfn func() //用于在新的M上启动某个特殊任务的函数。可能是系统监控/GC辅助/M自旋  
curg *g         //存放当前M正在运行的那个G的指针    
p puintptr      //指向与当前M相关联的那个P。mstartfn、curg和P最能体现当前M的即时情况。    
nextp puintptr  // 暂存与当前M有潜在关联的P，M和P的预联  
spinning bool   //表示这个M是否寻找可运行的G。在寻找过程中，M处于自旋状态  
lockedg *g      //GO运行时系统可以把一个M和一个G锁定在一起。一旦锁定，这个M就只能运行这个G，这个G也只能有该M运行。这个字段主要表示当前M锁定的那个G。*注意，在runtime包中可以锁定和解锁*
}

```

关于M的运行：
1. 创建之初会被加入全局的M列表（runtime.allm）,起始函数和预联的P也会被设置。
2. 运行时系统会为这个M创建一个新的内核线程并与之关联
3. M被创建之后，会被初始化，初始化完成后起始函数会执行。如果这个起始函数代表的是系统监控任务的话，则该M会一直执行它，而不会继续后面的流程。否则，起始函数执行完毕之后，当前M将会与那个预联的P完成关联。并准备执行其他任务
4. M有时候会被停止，如GC回收。停止后的M会被放在空闲列表（runtime.sched.midle），M是否空闲仅以它是否存在于调度器的空闲M列表为依据
5. 单个GO所使用的M最大数量默认为1w（几乎可以忽略这个限制），这个数量可以在runtime/debug中的SetMaxThreads函数设置。

#### 关于P（上下文环境）
P是G能够在M中运行的关键，与OS内核在CPU上实现切换不同的进程或者线程类型，GO在运行时也会让P与不同的M建立或者断开关联。  

P的最大数量默认值会与当前CPU的总核心数相同，但是有个**硬性上限值256**，如果环境变量GOMAXPROCS的值大于0，且大于256，则直接认定为256  
改变单个GO程序间接拥有的P的最大数量方法：
1. 调用函数runtime.GOMAXPROCS
2. 在go程序运行前设置环境变量GOMAXPROCS的值

P的数量即为可运行G的队列数量。  
P会不停的为G找到空闲的M去运行。  
在GO处理P的时候，也会有一个全局P列表（runtime.allp）以及一个空闲的P列表（runtime.sched.pidle）  

P本身是带着状态的：
* Pidle。此状态表示P未与任何M存在关联。在P初始化后，系统会将状态设置为Pidle，并放入调度器的空闲P列表（runtime.sched.pidle）  
* Prunning。此状态表示当前P正在与某个M关联
* Psyscall。此状态表明当前P中运行的G正在进行系统调用（运行M的任务时）
* Pgcstop。此状态表明运行时系统需要停止调度。比如：运行时系统在开始GC的某些步骤前，就会把全局P列表都置为此状态。P在创建之初的状态也是Pgcstop。
* Pdead。此状态表明当前P以及不会再被使用。如果GO程序在运行过程中，通过runtime.GOMAXPTOCS函数减少了P的最大数量，多余的O就会被运行时系统置于此状态。

正常的P的生命周期状态是：Pgcstop->Pidle->Prunning->Psyscall->Pdead  
其中注意几点:
1. 非Pdead状态的P都会在运行时系统欲停止调度时被置于Pgcstop状态
2. 等到重启调度后，Pgcstop的P并不恢复成原来状态，而是统一的转换未Pidle状态
3. 非Pgcstop的P可能因全局P列表的缩小而被认为时多余的，并被置为Pdead状态
4. 在P被置为Pdead状态之前，可运行G队列中的G会被转移到调度器的可运行的G队列，自由G列表也被转移到调度器的自由G队列

**在P的结构中，可运行G队列和自由G队列是重要组成部分**

#### 关于G（goroutine）




