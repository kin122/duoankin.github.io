goroutine:不要用共享内存的方式来通讯。作为替代，应该以通信作为手段来共享内存。  
GO的并发机制指的是用于支撑goroutine和channel的底层原理。**此处的原理主要包含在runtime的代码包**  

### 线程实现模型
* M：machine的缩写。一个M代表一个内核线程，或称为“工作线程”
* P：processor得缩写。一个P代表执行一个GO代码片段所必须的资源
* G：goroutine的缩写。一个G代表一个GO代码片段，前者是对后者的一种封装

简单的环境描述：  
一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境）。**每个P都会包含一个可运行的G的队列（runq）**。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。在这里我们把运行当前G的那个M称为“当前M”，并把与当前M关联的那个P称为“本地P”。  

M/P/G与内核调度实体（KSE）的关系： 
1. GO的运行时系统（runtime system）用M代表一个内核调度实体。
2. M与KSE之间的关联非常稳固，一个M在其生命周期内，会且仅会与一个KSE产生关联。即**M与KSE之间总是一对一的关系，一个M能且仅能代表一个内核线程**。
3. 相比之下，M与P、P与G之间的关联都是易变的。它们之间的对应关系会在实际调度中根据情况改变。
4. **M与P之间的关系也总是一对一的，而P与G之间的关系则是一对多的。**
5. 一个G终归会由一个M来负责运行，它们之间的关联会由P来牵线。

关于M（工作线程）
