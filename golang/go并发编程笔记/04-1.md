goroutine:不要用共享内存的方式来通讯。作为替代，应该以通信作为手段来共享内存。  
GO的并发机制指的是用于支撑goroutine和channel的底层原理。**此处的原理主要包含在runtime的代码包**  

### 线程实现模型
* M：machine的缩写。一个M代表一个内核线程，或称为“工作线程”
* P：processor得缩写。一个P代表执行一个GO代码片段所必须的资源
* G：goroutine的缩写。一个G代表一个GO代码片段，前者是对后者的一种封装

简单的环境描述：  
一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境）。**每个P都会包含一个可运行的G的队列（runq）**。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。在这里我们把运行当前G的那个M称为“当前M”，并把与当前M关联的那个P称为“本地P”。  

M/P/G与内核调度实体（KSE）的关系： 
1. GO的运行时系统（runtime system）用M代表一个内核调度实体。
2. M与KSE之间的关联非常稳固，一个M在其生命周期内，会且仅会与一个KSE产生关联。即**M与KSE之间总是一对一的关系，一个M能且仅能代表一个内核线程**。
3. 相比之下，M与P、P与G之间的关联都是易变的。它们之间的对应关系会在实际调度中根据情况改变。
4. **M与P之间的关系也总是一对一的，而P与G之间的关系则是一对多的。**
5. 一个G终归会由一个M来负责运行，它们之间的关联会由P来牵线。

#### 关于M（工作线程）
关于M的创建时机（M的个数随着需求增加，并非运行一开始固定）：
* 大多数情况下，创建一个M，都是由于没有足够的M来关联P并运行其中可运行的G。
* 系统执行系统监控或垃圾回收等任务的时候，也会导致新的M创建。

M结构：
```
type m struct{
go *g           //是一个特殊的goroutine字段，是GO运行时系统在启动之初创建的，用于执行一些运行时的任务  
mstartfn func() //用于在新的M上启动某个特殊任务的函数。可能是系统监控/GC辅助/M自旋  
curg *g         //存放当前M正在运行的那个G的指针    
p puintptr      //指向与当前M相关联的那个P。mstartfn、curg和P最能体现当前M的即时情况。    
nextp puintptr  // 暂存与当前M有潜在关联的P，M和P的预联  
spinning bool   //表示这个M是否寻找可运行的G。在寻找过程中，M处于自旋状态  
lockedg *g      //GO运行时系统可以把一个M和一个G锁定在一起。一旦锁定，这个M就只能运行这个G，这个G也只能有该M运行。这个字段主要表示当前M锁定的那个G。*注意，在runtime包中可以锁定和解锁*
}

```

关于M的运行：
1. 创建之初会被加入全局的M列表（runtime.allm）,起始函数和预联的P也会被设置。
2. 运行时系统会为这个M创建一个新的内核线程并与之关联
3. M被创建之后，会被初始化，初始化完成后起始函数会执行。如果这个起始函数代表的是系统监控任务的话，则该M会一直执行它，而不会继续后面的流程。否则，起始函数执行完毕之后，当前M将会与那个预联的P完成关联。并准备执行其他任务
4. M有时候会被停止，如GC回收。停止后的M会被放在空闲列表（runtime.sched.midle），M是否空闲仅以它是否存在于调度器的空闲M列表为依据
5. 单个GO所使用的M最大数量默认为1w（几乎可以忽略这个限制），这个数量可以在runtime/debug中的SetMaxThreads函数设置。

#### 关于P（上下文环境）
P是G能够在M中运行的关键，与OS内核在CPU上实现切换不同的进程或者线程类型，GO在运行时也会让P与不同的M建立或者断开关联。  

P的最大数量默认值会与当前CPU的总核心数相同，但是有个**硬性上限值256**，如果环境变量GOMAXPROCS的值大于0，且大于256，则直接认定为256  
改变单个GO程序间接拥有的P的最大数量方法：
1. 调用函数runtime.GOMAXPROCS
2. 在go程序运行前设置环境变量GOMAXPROCS的值

P的数量即为可运行G的队列数量。  
P会不停的为G找到空闲的M去运行。  
在GO处理P的时候，也会有一个全局P列表（runtime.allp）以及一个空闲的P列表（runtime.sched.pidle）  

P本身是带着状态的：
* Pidle。此状态表示P未与任何M存在关联。在P初始化后，系统会将状态设置为Pidle，并放入调度器的空闲P列表（runtime.sched.pidle）  
* Prunning。此状态表示当前P正在与某个M关联
* Psyscall。此状态表明当前P中运行的G正在进行系统调用（运行M的任务时）
* Pgcstop。此状态表明运行时系统需要停止调度。比如：运行时系统在开始GC的某些步骤前，就会把全局P列表都置为此状态。P在创建之初的状态也是Pgcstop。
* Pdead。此状态表明当前P以及不会再被使用。如果GO程序在运行过程中，通过runtime.GOMAXPTOCS函数减少了P的最大数量，多余的O就会被运行时系统置于此状态。

正常的P的生命周期状态是：Pgcstop->Pidle->Prunning->Psyscall->Pdead  
其中注意几点:
1. 非Pdead状态的P都会在运行时系统欲停止调度时被置于Pgcstop状态
2. 等到重启调度后，Pgcstop的P并不恢复成原来状态，而是统一的转换未Pidle状态
3. 非Pgcstop的P可能因全局P列表的缩小而被认为时多余的，并被置为Pdead状态
4. 在P被置为Pdead状态之前，可运行G队列中的G会被转移到调度器的可运行的G队列，自由G列表也被转移到调度器的自由G队列

**在P的结构中，可运行G队列和自由G队列是重要组成部分**

#### 关于G（goroutine）
GO代码中并发任务内容的主要载体  
GO的编译器会把go语句编程对内部函数newproc的调用，并把go函数及其参数都作为参数传递给这个函数。是一种递送并发任务的方法。  

G也有一个全局列表（runtime.allgs）,新建的G都会在第一时间加入这个列表，此全局列表的主要作用：集中存放当前运行时系统中的所有G指针。  
G创建完后会有以下运行逻辑：
1. 初始化完的G会被存储到本地P的runnext字段。
2. 如果当前P的runnext已经有一个G，那么已有的G就会被“踢到”该P的可运行G队列的末尾
3. 如果队列已满，则只能追加到调度器的可运行G队列中
4. GO会在为及试运行每个G忙碌着

G的主要状态如下：
* Gidle，表示当前G刚被新分配，但还未初始化
* Grunnable，表示当前G正在可运行队列中等待运行
* Grunning，表示当前G正在运行
* Gsyscall，表示当前G正在执行某个系统调用
* Gwaiting，表示当前G正在阻塞
* Gdead，表示当前G正在闲置
* Gcopystack，表示当前G的栈正在被移动，移动的原因可能是栈的扩展或者收缩
* Gscan，在GC扫描时与其它状态组合成的一个状态，是一个附加状态不可独立存在

G的生命周期状态：
![G状态转换](https://github.com/kin122/duoankin.github.io/blob/main/golang/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/G%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.xmind)

其中的注意点：
1. G在运行中，是否等待某个时间以及会等待什么样的时间，完全由其封装的go函数决定。
2. G在退出Gsyscall的时候并不一定能直接运行，如果不能直接运行，则转换为Grunnable放入调度器的可运行G队列中。
3. 进入Gdead的G是可以重新初始化并使用的（放入本地P或者调度器的自由G列表），这与Pdead并不一样（Pdead只会被销毁）

#### 关于M/P/G的容器（列表或者队列）
*注意此处容器列表的特性是先进后出（FILO），队列的特性则是先进先出(FIFO)*  

容器的相关内容：
* 全局M列表：runtime.allm,作用域运行时系统。存放所有M的**单向链表**
* 全局P列表：runtime.allp,作用域运行时系统。存放所有P的一个**数组**
* 全局G列表：runtime.allgs，作用域运行时系统。存放所有G的一个**切片**
* 调度器的空闲M列表：runtime.sched.midle,作用域为调度器。存放空闲的M的一个**单向链表**
* 调度器的空闲P列表：runtime.sched.pidle,作用域为调度器。存放空闲的P的一个**单向链表**
* 调度器的可运行G队列：runtime.sched.runqhead/runtime.sched.runqtail，作用域为调度器。存放可运行的G的一个**队列**
* 调度器的自由G列表：runtime.sched.gfreeStack/runtime.sched.gfreeNoStack,作用域为调度器。存放自由的G的两个**单向链表**
* P的可运行G队列：runtime.p.runq,作用域为本地P。存放当前P中的可运行G的一个**队列**
* P的自由列表：runtime.p.gfree,作用域为本地P。存放当前P中的自由G的一个**单向链表**

注意点：
1. 两个可运行G队列都拥有机会平等的运行机会。两个可运行G队列之间也会相互转移G
2. Gsyscall状态转出的G都会被放入调度器的可运行G队列；系统初始化的G都会被放入本地P的可运行G队列；Gwaiting状态转出的G则两个队列都可能放入，亦有可能直接运行
3. *注意runtime.GOMAXPROCS函数调用时的G队列转移的特殊情况。*
4. G转为Gdead状态后，会首先被放入本地P的自由G列表，本地P的自由G列表满了后，系统会将其中的一些G转移到调度器的自由G列表。而在系统需要自由G的时候，也是先拿本地P的自由G列表，空了再去拿调度器的自由G列表
5. 调度器的自由G列表有两个，名称上可以看出为有栈还是无栈。判断G有无栈的方法为：把G放入自由G列表之前，系统会检查该G的栈空间是否为初始大小，如果不是则释放为无栈；从自由G列表中取出G之后，运行是系统会检查它是否拥有栈，如果没有就初始化一个新的栈给它。

**调度器**其实就是GO程序运行时系统，也就是M/P/G的一个主要模型实现载体。一个GO程序中只会存在一个调度器实例。





